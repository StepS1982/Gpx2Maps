<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GPX2MAPS Web-APP</title>
  <meta name="description" content="Software per gestire al 100% itinerari con Google Maps in modalità navigabile" />
  <style>
    :root{
      --accent:#e11d48; --fg:#0f172a; --muted:#475569; --bg:#f8fafc;
      --card:#fff; --border:#e2e8f0; --btn:#0ea5e9; --btn2:#22c55e; --btnDanger:#ef4444;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;color:var(--fg);background:var(--bg)}
    header{padding:20px 16px 8px;background:var(--card);border-bottom:1px solid var(--border)}
    .hero{max-width:1100px;margin:0 auto;display:flex;align-items:center;gap:16px}
    .hero img{width:44px;height:44px;border-radius:10px}
    .title{font-weight:800;font-size:24px;line-height:1.1}
    .subtitle{color:var(--accent);font-weight:700}
    .cta{margin:12px 0 0;display:flex;justify-content:center;gap:10px;flex-wrap:wrap}
    .btn{appearance:none;border:1px solid transparent;background:var(--btn);color:#fff;padding:10px 14px;border-radius:999px;cursor:pointer;font-weight:700}
    .btn.secondary{background:var(--btn2)} .btn.ghost{background:#fff;color:var(--fg);border-color:var(--border)} .btn.small{padding:6px 10px;font-weight:600} .btn.danger{background:var(--btnDanger)}
    .btn.xs{padding:4px 8px;font-size:12px;line-height:1.1;border-radius:999px;font-weight:700}
    /* chip giallina */
    .btn.chip-yellow{
      background:#fff8b5;          /* canarino leggero */
      color:#4d3d00;               /* testo leggibile */
      border-color:#f0e38a;
    }
    .btn.chip-yellow:hover,
    .btn.chip-yellow:focus{
      background:#fff49a;
      border-color:#eadc73;
    }
    .container{max-width:1100px;margin:0 auto;padding:16px}
    .note{margin:14px 0 6px;color:var(--muted);font-size:14px}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;border-bottom:1px solid var(--border);margin-top:12px}
    .tab{padding:10px 12px;cursor:pointer;border:1px solid var(--border);border-bottom:none;border-radius:10px 10px 0 0;background:#f1f5f9;font-weight:700}
    .tab.active{background:#fff;color:#0ea5e9}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
    .card .hd{padding:14px 16px;border-bottom:1px solid var(--border);font-weight:800}
    .card .bd{padding:16px}
    .grid{display:grid;grid-template-columns:1fr;gap:16px}
    @media(min-width:900px){.grid-2{grid-template-columns:1.4fr 1fr}}
    textarea{width:100%;min-height:180px;resize:vertical;padding:12px;border-radius:10px;border:1px solid var(--border);font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;word-break:break-all}
    dialog{border:none;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.2);width:min(560px,92vw)} dialog::backdrop{background:rgba(0,0,0,.35)}
    #toastsCenter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;z-index:60}
    .toast.center{padding:12px 16px;font-size:15px;background:rgba(17,24,39,.95);color:#fff;border-radius:10px;box-shadow:0 6px 16px rgba(0,0,0,.28);animation:fadePop .28s ease-out}
    @keyframes fadePop{from{opacity:0;transform:translateY(6px) scale(.98)}to{opacity:1;transform:translateY(0) scale(1)}}
    .out-item+.out-item{margin-top:8px}
    footer{margin:36px auto 24px;max-width:1100px;color:var(--muted);font-size:13px;padding:0 16px}
  </style>
</head>
<body>
  <header>
    <div class="hero">
      <img src="/gpx2maps_icon_1024.png" alt="Logo GPX2MAPS" />
      <div>
        <div class="title">GPX2MAPS Web-APP</div>
        <div class="subtitle">by Pieghello</div>
      </div>
    </div>
    <div class="cta">
      <a id="donateBtn" class="btn" href="#" target="_blank" rel="noopener">Dona</a>
      <a id="amazonBtn" class="btn secondary" href="#" target="_blank" rel="noopener">Offerte e Coupon Amazon</a>
    </div>
  </header>

  <div class="container">
    <div class="note">Software per gestire al 100% itinerari con Google Maps in modalità navigabile</div>

    <div class="tabs" role="tablist">
      <button class="tab active" role="tab" aria-selected="true"  data-tab="merge">Fusione Link</button>
      <button class="tab"         role="tab" aria-selected="false" data-tab="maps2gpx">2) Google Maps → GPX</button>
      <button class="tab"         role="tab" aria-selected="false" data-tab="gpx2maps">3) GPX → Google Maps</button>
      <button class="tab"         role="tab" aria-selected="false" data-tab="sanitize">4) Sanitizza GPX</button>
      <button class="tab"         role="tab" aria-selected="false" data-tab="meteo">5) Meteo + Info percorso</button>
    </div>

    <!-- TAB 1 -->
    <section id="tab-merge" class="card">
      <div class="hd">Fusione, ottimizzazione e split dei link Google Maps</div>
      <div class="bd grid grid-2">
        <p class="note" style="grid-column:1/-1;">
          Il limite su Google Maps è di 10 punti, con questo strumento possiamo arrivare a 25 in modalità navigabile che è il vero limite nascosto di Google. Se si dovessero superare i 25 punti, verrebbe proposto o di ottimizzare a 25, mantenendo fissi il primo e l'ultimo punto, oppure si possono generare tanti link da 25 punti fino al completamento dell'intero itinerario
        </p>
        <div>
          <label for="linksInput" style="font-weight:800;">Incolla i link (uno per riga)</label>
          <textarea id="linksInput" placeholder="Incolla link tipo https://www.google.*/maps/dir/... (uno per riga). Accetta anche maps.app.goo.gl"></textarea>
          <div class="row" style="margin-top:12px;">
            <button id="btnMerge" class="btn">Analizza e Unisci</button>
            <button id="btnClear" class="btn ghost">Pulisci</button>
          </div>
        </div>
        <div>
          <div class="out card">
            <div class="hd">Risultati</div>
            <div class="bd">
              <div id="stats" class="note">Nessun risultato ancora.</div>
              <div id="output"></div>
              <div class="row" style="margin-top:10px;">
                <button id="btnDownloadAll" class="btn small" style="display:none;">Scarica .txt</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- TAB 2 -->
    <section id="tab-maps2gpx" class="card" hidden>
      <div class="hd" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
        <span>2) Google Maps → GPX</span>
        <a class="btn xs chip-yellow"
           href="https://mapstogpx.com/"
           target="_blank" rel="noopener"
           style="white-space:nowrap;margin-left:10px;">
          Sito WEB esterno per la conversione da Maps a GPX
        </a>
      </div>
      <div class="bd grid grid-2">
        <div>
          <label for="maps2gpxInput" style="font-weight:800;">Incolla un link Google Maps (itinerario) o una lista di indirizzi/coordinate</label>
          <textarea id="maps2gpxInput" placeholder="Esempi:
- https://www.google.com/maps/dir/Punto+A/Punto+B/...
- Indirizzi o lat,lon (uno per riga)
- Puoi incollare link con // iniziale: qui viene ignorato (come nello script)"></textarea>
          <div class="row" style="margin-top:12px;">
            <button id="btnGenGPX" class="btn">Genera GPX</button>
            <button id="btnClear2" class="btn ghost">Pulisci</button>
          </div>
        </div>
        <div>
          <div class="out card">
            <div class="hd">Risultati</div>
            <div class="bd">
              <div id="stats2" class="note">Nessun file generato.</div>
              <details id="previewWrapRte" style="margin-top:8px;" hidden>
                <summary>Anteprima GPX Rotta (WPT + RTE)</summary>
                <pre id="gpxPreviewRte" class="mono" style="max-height:220px;overflow:auto;white-space:pre;background:#f8fafc;border:1px solid var(--border);padding:10px;border-radius:10px;"></pre>
              </details>
              <details id="previewWrapTrk" style="margin-top:8px;" hidden>
                <summary>Anteprima GPX Traccia (WPT + TRK)</summary>
                <pre id="gpxPreviewTrk" class="mono" style="max-height:220px;overflow:auto;white-space:pre;background:#f8fafc;border:1px solid var(--border);padding:10px;border-radius:10px;"></pre>
              </details>
              <div class="row" id="dlRow" style="margin-top:10px;display:none;">
                <button id="btnDownloadRTE" class="btn small">Scarica GPX Rotta</button>
                <button id="btnDownloadTRK" class="btn small">Scarica GPX Traccia</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Placeholder altri tab -->
    <section id="tab-gpx2maps" class="card" hidden>
      <div class="hd">3) GPX → Google Maps</div>
      <div class="bd grid grid-2">
        <div>
          <label for="gpxText" style="font-weight:800;">Carica un file GPX (o incolla il testo)</label>
        
          <!-- textarea PRIMA, come nel tab Sanitizza -->
          <textarea id="gpxText" placeholder="(Opzionale) Incolla qui il contenuto GPX se non usi il file"></textarea>
        
          <!-- pulsanti SOTTO la textarea, come nel tab Sanitizza -->
          <div class="row" style="margin-top:12px;">
            <input id="gpxFile" type="file" accept=".gpx,application/gpx+xml,text/xml" />
            <button id="btnParseGPX" class="btn">Analizza GPX</button>
            <button id="btnClear3" class="btn ghost">Pulisci</button>
          </div>
        
          <div id="whichButtons" class="row" style="margin-top:10px; display:none;">
            <button id="btnMakeWPT" class="btn small">Crea link da WPT</button>
            <button id="btnMakeRTE" class="btn small">Crea link da RTE</button>
            <button id="btnMakeTRK" class="btn small">Crea link da TRK</button>
          </div>
        </div>
        <div>
          <div class="out card">
            <div class="hd">Risultati</div>
            <div class="bd">
              <div id="stats3" class="note">Nessun GPX analizzato.</div>
              <div id="output3"></div>
              <div class="row" style="margin-top:10px;">
                <button id="btnDownloadAll3" class="btn small" style="display:none;">Scarica .txt</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <!-- TAB 4 -->
    <section id="tab-sanitize" class="card" hidden>
      <div class="hd">4) Sanitizza GPX</div>
      <div class="bd grid grid-2">
        <div>
          <label for="sanitizeInput" style="font-weight:800;">Incolla il GPX (oppure apri un file)</label>
          <textarea id="sanitizeInput" placeholder="Incolla qui il contenuto del file .gpx"></textarea>
          <div class="row" style="margin-top:12px;">
            <input id="sanitizeFile" type="file" accept=".gpx,application/gpx+xml" />
            <button id="btnSanitize" class="btn">Sanifica GPX</button>
            <button id="btnClear4" class="btn ghost">Pulisci</button>
          </div>
        </div>
        <div>
          <div class="out card">
            <div class="hd">Risultati</div>
            <div class="bd">
              <div id="stats4" class="note">Nessun file sanificato.</div>
              <details id="previewWrapSan" style="margin-top:8px;" hidden>
                <summary>Anteprima GPX sanificato</summary>
                <pre id="gpxPreviewSan" class="mono" style="max-height:220px;overflow:auto;white-space:pre;background:#f8fafc;border:1px solid var(--border);padding:10px;border-radius:10px;"></pre>
              </details>
              <div class="row" id="dlRow4" style="margin-top:10px;display:none;">
                <button id="btnDownloadSan" class="btn small">Scarica GPX sanificato</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <!-- TAB 5 -->
    <section id="tab-meteo" class="card" hidden>
      <div class="hd">5) Meteo + Info percorso</div>
      <div class="bd grid grid-2">
        <div>
          <label for="meteoInput" style="font-weight:800;">Incolla un link Google Maps (unico) o una lista di località/coordinate (una per riga)</label>
          <textarea id="meteoInput" placeholder="Esempi:
    - https://www.google.com/maps/dir/...
    - https://maps.app.goo.gl/...
    - Località o lat,lon (una per riga)
    Nota: se il long link fosse /maps/dir//... ti chiederò la prima località."></textarea>
          <div class="row" style="margin-top:12px;">
            <button id="btnGenMeteo" class="btn">Genera Meteo + Info percorso</button>
            <button id="btnClearMeteo" class="btn ghost">Pulisci</button>
          </div>
        </div>
    
        <div>
          <div class="out card">
            <div class="hd">File generati</div>
            <div class="bd" id="meteoOut">
              <div class="note">Nessun file generato.</div>
              <div id="meteoFiles"></div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <footer>
    L'applicazione è stata realizzata a scopo gratuito per la comunità. Se si vuole fare un'opera di gentilezza nei confronti dello sviluppatore che ci ha perso del tempo per realizzarla, si prega di effettuare una donazione con il pulsante ‘Dona’ in alto. Approfitta anche del link diretto alla pagina nascosta di Amazon con tutte le offerte e coupon, che è accessibile con il pulsante che si trova sempre in alto.
  </footer>

  <!-- Modals -->
  <dialog id="confirmDialog">
    <form method="dialog" style="padding:18px 18px 8px;">
      <h3 style="margin:0 0 6px;font-weight:900;">Confermi l'operazione?</h3>
      <p id="confirmText" style="margin:0 0 14px;color:var(--muted);"></p>
      <div class="row" style="justify-content:flex-end;">
        <button class="btn ghost" value="cancel">Annulla</button>
        <button class="btn" value="ok">Conferma</button>
      </div>
    </form>
  </dialog>

  <dialog id="strategyDialog">
    <form method="dialog" style="padding:18px 18px 8px;">
      <h3 style="margin:0 0 6px;font-weight:900;">Troppi punti per un singolo link</h3>
      <p style="margin:0 0 10px;color:var(--muted);">Hai superato il limite di 25 (incluso il primo punto con la tua posizione GPS). Scegli una strategia:</p>
      <div class="row" style="flex-direction:column;align-items:stretch;gap:10px;">
        <button id="btnStrategyOptimize" class="btn" value="opt">1) Ottimizza a 25 (mantieni testa/coda, campiona gli intermedi)</button>
        <button id="btnStrategySplit" class="btn secondary" value="split">2) Dividi in più link (max 25 punti; solo il primo ha “//”)</button>
      </div>
      <div class="row" style="justify-content:flex-end;margin-top:10px;">
        <button class="btn ghost" value="cancel">Chiudi</button>
      </div>
    </form>
  </dialog>

  <div id="toastsCenter" aria-live="polite" aria-atomic="true"></div>

  <script>
    /* === CONFIG senza object literal (no caratteri invisibili) === */
    const CONFIG = {};
    CONFIG.workerBase = "https://gpx2maps-worker.stefano-vitro.workers.dev";
    CONFIG.paypalDonateUrl = "https://www.paypal.com/donate?business=stefano.vitro%40gmail.com&no_recurring=0&item_name=Supporto+sviluppo+GPX2MAPS&currency_code=EUR";
    CONFIG.amazonAffiliateUrl = "https://amzn.to/41o2XjA";

    document.getElementById('donateBtn').href=CONFIG.paypalDonateUrl;
    document.getElementById('amazonBtn').href=CONFIG.amazonAffiliateUrl;

    /* Tabs */
    const tabs=[...document.querySelectorAll('.tab')];
    tabs.forEach(btn=>btn.addEventListener('click',()=>{
      tabs.forEach(b=>{b.classList.remove('active');b.setAttribute('aria-selected','false')});
      btn.classList.add('active');btn.setAttribute('aria-selected','true');
      const id=btn.dataset.tab;
      ['merge','maps2gpx','gpx2maps','sanitize','meteo'].forEach(k=>{
        const s=document.getElementById(`tab-${k}`);
        if(s) s.hidden = k!==id && !(k==='merge'&&id===undefined);
      });
    }));

    /* Toast center in coda (5s, niente overwrite) */
    const _toastQ = [];
    let _toastShowing = false;
    
    function _toastShowNext(){
      if(_toastShowing || !_toastQ.length) return;
      _toastShowing = true;
      const msg = _toastQ.shift();
      const box = document.getElementById('toastsCenter');
      const t = document.createElement('div');
      t.className = 'toast center';
      t.textContent = msg;
      box.appendChild(t);
      setTimeout(()=>{
        if(t.parentNode) t.parentNode.removeChild(t);
        _toastShowing = false;
        _toastShowNext();
      }, 5000);
    }
    function toastCenter(msg){ _toastQ.push(msg); _toastShowNext(); }
    function toast(msg){ toastCenter(msg); }
    
    async function confirmAction(text){
      const dlg=document.getElementById('confirmDialog');
      document.getElementById('confirmText').textContent=text||'';
      dlg.showModal();
      const v=await new Promise(r=>dlg.addEventListener('close',()=>r(dlg.returnValue),{once:true}));
      return v==='ok';
    }
    async function getJSON(u){
      const r=await fetch(u,{headers:{'Accept':'application/json'}});
      if(!r.ok) throw new Error('HTTP '+r.status);
      return r.json();
    }

    /* Helpers */
    // === Helpers per matching "strict" token vs display_name Nominatim
    /* POI hard-coded (eccezioni controllate) */
    const POI_FIX = [
      {
        label: 'Orrido di Bracca',
        lat: '45.846870', lon: '9.731200',
        match: (raw) => {
          const n = normText(raw);
          // copre “Orrido di Bracca”, “Orrido del Bracca”, varianti con punteggiatura o plus
          return n.includes('orrido di bracca') || n.includes('orrido del bracca') || n.includes('orrido bracca');
        }
      },
      {
        label: 'Passo del Grimsel',
        lat: '46.561400', lon: '8.337580',
        match: (raw) => {
          const n = normText(raw);
          // copre "Passo del Grimsel", "Grimselpass", ecc.
          return n.includes('grimsel');
        }
      },
    ];
    // --- normalizzazioni/sinonimi per match "leggero" ---
    function normStr(s){
      return String(s).toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
        .replace(/[.,;:()'’"“”]/g,' ')
        .replace(/\s+/g,' ').trim();
    }
    // gruppo di equivalenze: la prima parola è il "core"
    const SYN_EQUIV = [
      ['grimsel','grimselpass','passodelgrimsel','grimsel pass',
       'grimselpasshohe','grimselpasshöhe','grimsel-pass','grimsel-passhohe','grimsel-passhöhe'],
      ['nufenen','novena','nufenenpass','passonovena','passo della novena'],
      ['sempione','simplon','simplonpass','passodelsempione','passo del sempione'],
      ['goms','obergoms'],
      ['svizzera','switzerland'],
      ['italia','italy']
    ];
    function applySynonyms(s){
      let out = ' ' + normStr(s) + ' ';
      for(const group of SYN_EQUIV){
        const core = group[0];
        for(const alias of group){
          const re = new RegExp(`(?<=\\s)${alias.replace(/[-/\\^$*+?.()|[\]{}]/g,'\\$&')}(?=\\s)`,'g');
          out = out.replace(re, ` ${core} `);
        }
      }
      return out.trim();
    }
    // parole generiche da ignorare nei keyword
    const GENERIC_WORDS = new Set([
      'passo','pass','colle','forcella','galleria','tunnel','orrido',
      'provincia','cantone','distretto','circolo','comune'
    ]);    
    function keywordsForMatch(token){
      const words = applySynonyms(token).split(' ');
      const out = [];
      for(const w of words){
        if(!w) continue;
        if(GENERIC_WORDS.has(w)) continue;
        if(/^\d+$/.test(w)) continue;
        if(w.length<=2) continue;
        out.push(w);
      }
      return [...new Set(out)];
    }
    const IT_STOP = new Set([
      'di','del','della','delle','dei','degli','la','il','lo','i','gli','le','e','ed',
      'in','da','su','al','ai','agli','alla','alle','dal','sul','per','con',
      // paesi/province/sigle
      'italia','svizzera','switzerland','italy','provincia','province',
      'mi','co','va','lc','bg','ge','no','vb','vs'
    ]);
    function keywordsFromToken(s){
      const arr = applySynonyms(s).split(' ');
      return arr.filter(w => {
        if(!w) return false;
        if(IT_STOP.has(w)) return false;
        if(/^[0-9]+$/.test(w)) return false;     // ZIP/civici
        if(w.length <= 3) return false;          // sigle molto corte
        return true;
      });
    }
    // match "severo ma giusto", con soglia morbida per passi/colle
    function nameMatchesToken(token, display){
      const hayNorm = ' ' + applySynonyms(display) + ' ';
      const tokNorm = applySynonyms(token);
      const kw = keywordsForMatch(tokNorm);
      if(!kw.length) return true;
    
      // caso "passo/colle": basta che compaia il nome del passo
      const PASS_KEYS = ['grimsel','nufenen','novena','sempione','simplon'];
      const isPass = /\b(pass|passo|colle)\b/i.test(tokNorm);
      if(isPass){
        for(const k of PASS_KEYS){
          if(tokNorm.includes(k) && hayNorm.includes(' ' + k + ' ')) return true;
        }
      }
    
      let hit=0;
      for(const w of kw){
        if(hayNorm.includes(' ' + w + ' ') || hayNorm.includes(w)) hit++;
      }
      const threshold = isPass ? 0.45 : 0.60;
      return (hit/kw.length) >= threshold;
    }
    // pulizia *prima* del geocoding (togli CAP/codici, “Provincia di …”)
    function cleanForGeocode(t){
      let s = decodeTok(t);
      s = s.replace(/\bch[-\s]?\d{4,5}\b/gi,''); // CH-3999
      s = s.replace(/\b\d{4,5}\b/g,'');         // 3999, 3907, 20100...
      s = s.replace(/,\s*(?:MI|CO|VA|LC|BG|GE|NO|VB|VS|TI|GR|UR|BE|ZH|ZG|SG|VD|JU|FR|BS|BL|AG|SO|AR|AI|GE|LU|NE|OW|NW|SH|SZ|TG)\b/gi,'');
      s = s.replace(/\bprovincia\s+di\s+[a-zà-ù]+/gi,'');
      s = s.replace(/\s*,\s*,+/g,',');          // comprime virgole doppie
      s = s.replace(/^[,\s]+|[,\s]+$/g,'');     // toglie virgole/spazi ai bordi
      s = s.replace(/\s{2,}/g,' ').trim();
      if(s.endsWith(',')) s = s.slice(0,-1).trim();
      return s;
    }
    function looksLocalityClass(g){
      const c = String(g && g.class || '');
      return /^(place|boundary|highway|natural|mountain_pass|waterway|aeroway|railway|man_made)$/.test(c);
    }
    function tokenMentionsCountry(t){
      return /\b(italia|svizzera|francia|france|germania|austria|slovenia)\b/i.test(String(t));
    }
    // === Riconoscimento "località" vs "POI/commerciale" + match stretto per POI ===
    const POI_KEYWORDS = [
      'autogrill','hotel','ristorante','pizzeria','birroteca','trattoria','osteria','bar',
      'mcdonald','burger king','ikea','decathlon','outlet','supermercato','esselunga',
      'carrefour','coop','lidl','iper','ipercoop','conad','eni','q8','tamoil','ip',
      'stazione di servizio','area di servizio','area servizio','services','service'
    ];
    const STREET_WORDS_RE = /\b(via|viale|piazza|piazzale|corso|largo|strada|autostrada|uscita|svincolo|tangenziale)\b/i;
    const ROAD_CODE_RE    = /\b(a\d+|ss\d+|sp\d+|sr\d+)\b/i;
    
    function _norm(s){
      return String(s||'').toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g,''); // senza accenti
    }
    function hasPOIKeyword(token){
      const s=_norm(token);
      return POI_KEYWORDS.some(k=>s.includes(k));
    }
    function coreWordsForPOI(token){
      const s=_norm(token).replace(/[^\p{L}\p{N}\s]/gu,' ');
      const stop = new Set(['italia','italy','svizzera','switzerland','provincia','comune','citta','city','town','village','hamlet','localita',
        'di','del','della','delle','degli','dei','da','dal','dallo','dalla','allo','alla','al','ai','agli','alle','lo','la','le','il','in','su'
      ]);
      return s.split(/\s+/).filter(w => w && w.length>=3 && !stop.has(w) && !/^\d{5}$/.test(w));
    }
    function isLocalityToken(token){
      const s=_norm(token);
      if (STREET_WORDS_RE.test(s)) return false;
      if (ROAD_CODE_RE.test(s))   return false;
      if (hasPOIKeyword(token))   return false;
      // indirizzo preciso "Via ..., 11"
      if (/, *\d+\b/.test(token) && /\b(via|viale|piazza|corso|largo|piazzale)\b/i.test(token)) return false;
      return true;
    }
    function poiAccept(token, geocoded){
      if(!geocoded) return false;
      const disp=_norm(geocoded.display_name||'');
      const cls=(geocoded.class||geocoded.category||'').toLowerCase();
      const type=(geocoded.type||'').toLowerCase();
    
      const words = coreWordsForPOI(token);
      let hits=0; for(const w of words){ if(disp.includes(w)) hits++; }
    
      // se il token ha un brand esplicito, deve comparire nel risultato
      const tokenHasBrand = hasPOIKeyword(token);
      const brandOk = !tokenHasBrand || POI_KEYWORDS.some(k=>disp.includes(k));
    
      // classi accettabili per POI; per highway accettiamo solo aree/servizi autostradali
      const classOk = /^(amenity|tourism|shop|leisure|man_made|highway|place)$/.test(cls);
      const highwayOk = (cls!=='highway') || /^(services|rest_area|motorway_junction|service|fuel)$/.test(type);
    
      // Match stretto: almeno 2 parole significative, e se c'è brand dev'essere presente
      return classOk && highwayOk && brandOk && (hits>=2);
    }
    
    // === Indizi per validare i fallback Nominatim ===
    function hasCountryWord(s){
      return /\b(italia|italy|svizzera|switzerland)\b/i.test(s);
    }
    function hintsFromToken(token){
      const cap = (token.match(/\b\d{5}\b/g)||[])[0] || null;       // CAP italiano
      const parts = token.split(',').map(x=>x.trim()).filter(Boolean);
      const tail = parts.slice(-2).join(' ');                       // ultime 1-2 parti
      const tailKw = _norm(tail).split(/\s+/).filter(w=>w.length>=4 && /^[a-z]/.test(w));
      return { cap, tailKw };
    }
    function acceptByHints(originalToken, geocoded){
      if(!geocoded) return false;
      const disp = _norm(geocoded.display_name||'');
      const {cap, tailKw} = hintsFromToken(originalToken);
    
      // 1) CAP presente nel display_name => forte indicazione
      if(cap && disp.includes(cap)) return true;
    
      // 2) almeno 2 keyword significative dalle ultime parti compaiono nel display_name
      let hits = 0;
      for(const kw of tailKw){ if(disp.includes(kw)) hits++; }
      return hits >= 2;
    }
    function buildFallbackQueries(token){
      const out = [];
      const needCountry = !hasCountryWord(token);
      const add = q => { if(q && q!==token && !out.includes(q)) out.push(q); };
    
      const stripProvincia = s => s.replace(/\bprovincia di\b\s*/i,'').replace(/\bprov\.\s*/i,'');
    
      const parts = token.split(',').map(s=>s.trim()).filter(Boolean);
      if(parts.length>=2) add(stripProvincia(parts.slice(-2).join(', ')) + (needCountry? ', Italia' : ''));
      if(parts.length>=1) add(stripProvincia(parts.slice(-1)[0])          + (needCountry? ', Italia' : ''));
      add(stripProvincia(token) + (needCountry? ', Italia' : ''));
    
      return out;
    }
    
    // --- helper: pulizia minima indirizzi IT quando il primo tentativo fallisce ---
    function cleanAddressTokenForGeocode(raw){
      let s = decodeTok(raw).replace(/\s+/g,' ').trim();
    
      // 1) se il primo pezzo prima della virgola sembra un brand (niente numeri e non "via/viale/..."), lo scarto
      const parts = s.split(',');
      if (parts.length >= 2) {
        const first = parts[0].trim().toLowerCase();
        const looksLikeBrand = !/\d/.test(first) &&
          !/^(via|viale|v\.|viale|piazza|p\.za|corso|largo|strada|ss|sp|sr|autostrada|a\d+)/i.test(first);
        if (looksLikeBrand) s = parts.slice(1).join(',').trim();
      }
    
      // 2) tolgo eventuale sigla provincia finale (", MI" oppure " MI")
      s = s.replace(/,\s*[A-Z]{2}\b$/,'').replace(/\s+[A-Z]{2}\b$/,'');
    
      // 3) normalizzo un possibile inizio tipo "A1" -> "Autostrada A1" (aiuta Nominatim)
      s = s.replace(/^A(\d+)\b/i,'Autostrada A$1');
    
      return s.replace(/\s+/g,' ').trim();
    }
    // Normalizza query "rognose" (Provincia di..., CAP+sigla, ecc.)
    function normalizeQuery(q){
      let s = String(q);
    
      // "Provincia di Bergamo" -> "Bergamo"
      s = s.replace(/\bProvincia di\s+([^,]+)/gi, '$1');
    
      // ", 24121-24129" o ", 22100 CO" o ", 22100"
      s = s.replace(/,\s*\d{5}(?:-\d{5})?\s*[A-Z]{0,2}\b/gi, '');
    
      // ", CO" (solo sigla provincia)
      s = s.replace(/,\s*[A-Z]{2}\b/g, '');
    
      // spazi multipli / virgole sporche
      s = s.replace(/\s{2,}/g, ' ').replace(/\s*,\s*/g, ', ').trim();
    
      return s;
    }
    function stripAtTail(s){
      return s.replace(/\/@.*$/,'').replace(/\/data=.*$/,'').replace(/\?.*$/,'');
    }
    // Garantisce che ci sia sempre /maps/dir// (non // in mezzo)
    function ensureDirHead(url){
      return url.replace(/(\/maps\/dir\/)(?!\/)/, '$1/'); // -> .../dir//...
    }
    function decodeTok(p){ try{return decodeURIComponent(p).replace(/\+/g,' ').trim()}catch{return p.replace(/\+/g,' ').trim()} }
    function xmlEscape(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&apos;'); }
    function fileNameSafe(s){ return (s||'').replace(/[\\\/:*?"<>|]/g,'').replace(/\s+/g,' ').trim(); }
    function nowStamp(){ const d=new Date(),p=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}${p(d.getMonth()+1)}${p(d.getDate())}_${p(d.getHours())}${p(d.getMinutes())}${p(d.getSeconds())}`; }
    function timeHHMMSS(){ const d=new Date(),p=n=>String(n).padStart(2,'0'); return `${p(d.getHours())}:${p(d.getMinutes())}:${p(d.getSeconds())}`; }
    function joinLF(a){ return a.join('\n'); }
    // Normalizza un testo: toglie accenti, punteggiatura, lowercase e comprime gli spazi
    function normText(s){
      return String(s)
        .normalize('NFD').replace(/[\u0300-\u036f]/g,'') // rimuovi diacritici
        .toLowerCase()
        .replace(/[^a-z0-9]+/g,' ') // tieni solo lettere/numeri
        .trim();
    }
    // HALF-EVEN (banker's) a 6 decimali – come PS
    function roundHalfEvenStr(x, d=6){
      let s=(typeof x==='number')?x.toString():String(x).trim();
      if(!isFinite(+s)) return (0).toFixed(d);
      if(/[eE]/.test(s)) s=(+s).toFixed(d+10);
      let sign=''; if(s[0]==='-'||s[0]==='+'){ if(s[0]==='-') sign='-'; s=s.slice(1); }
      if(!s.includes('.')) s+='.0';
      let [I,F='']=s.split('.'); I=I.replace(/\D/g,'')||'0'; F=F.replace(/\D/g,'');
      while(F.length<d+1) F+='0';
      const keep=I.length+d, digits=I+F, kept=digits.slice(0,keep)||'0', firstDrop=digits[keep]||'0', restDrop=digits.slice(keep+1);
      let up=false;
      if(firstDrop>'5') up=true;
      else if(firstDrop<'5') up=false;
      else up = /[1-9]/.test(restDrop) ? true : (parseInt(kept[kept.length-1]||'0',10)%2===1);
      let n=BigInt(kept); if(up) n+=1n;
      let rs=n.toString(); while(rs.length<=d) rs='0'+rs;
      const pos=rs.length-d; let out=rs.slice(0,pos)+'.'+rs.slice(pos);
      if(sign==='-' && out!=='0.'+'0'.repeat(d)) out='-'+out;
      return out;
    }
    const fmt6s = x => roundHalfEvenStr(x, 6);

    /* ===== TAB 1: Merge ===== */
    function extractDirSegment(s){
      const m=stripAtTail(s.trim()).match(/^https?:\/\/[^/]*google\.[^/]+\/maps\/dir\/(.+)$/i);
      if(!m) return null;
      return m[1].replace(/^\/+/, '').replace(/\/+$/,''); // rimuovi slash iniziali per evitare /dir///
    }

    async function resolveForMeteo(url){
      let u = url;
    
      // segue shortlink (maps.app.goo.gl / goo.gl / g.co)
      try{
        const h=(new URL(url)).host;
        if (/(^|\.)maps\.app\.goo\.gl$/i.test(h) || /(^|\.)goo\.gl$/i.test(h) || /(^|\.)g\.co$/i.test(h)) {
          const {finalUrl} = await getJSON(`${CONFIG.workerBase}/resolve?url=${encodeURIComponent(url)}`);
          if (finalUrl) u = finalUrl;
        }
      }catch{}
    
      // se è un long google "strano" con daddr/saddr, per METEO usiamo saddr come primo punto (niente //)
      try{
        const U = new URL(u);
        const isGoogle = /(^|\.)google\./i.test(U.host);
        if (isGoogle && (U.pathname === '/' || U.pathname === '/maps')) {
          const decodePlus = s => decodeURIComponent(String(s).replace(/\+/g,' ')).trim();
          const daddr = U.searchParams.get('daddr');
          const saddr = U.searchParams.get('saddr');
          if (daddr){
            const dests = decodePlus(daddr).split(/\s+to:/i).map(s=>s.trim()).filter(Boolean);
            const segs = [];
            if (saddr) segs.push(encodeURIComponent(decodePlus(saddr)).replace(/%20/g,'+'));
            segs.push(...dests.map(s => encodeURIComponent(s).replace(/%20/g,'+')));
            return 'https://www.google.com/maps/dir/' + segs.join('/');
          }
        }
      }catch{}
    
      return u;
    }
    
    async function resolveIfShort(url){
      let u = url;
  
      // 1) segui gli shortlink (maps.app.goo.gl / goo.gl / g.co) via worker /resolve
      try{
        const h=(new URL(url)).host;
        if (/(^|\.)maps\.app\.goo\.gl$/i.test(h) || /(^|\.)goo\.gl$/i.test(h) || /(^|\.)g\.co$/i.test(h)) {
          const {finalUrl} = await getJSON(`${CONFIG.workerBase}/resolve?url=${encodeURIComponent(url)}`);
          if (finalUrl) u = finalUrl;
        }
      }catch{}
  
      // 2) se è un long "strano" di Google con daddr/to: (anche path "/")
      try{
        const U = new URL(u);
        const isGoogle = /(^|\.)google\./i.test(U.host);
        if (isGoogle && (U.pathname === '/' || U.pathname === '/maps')) {
          const raw = U.searchParams.get('daddr');
          if (raw) {
            // decodifica con "+" -> spazio
            const decodePlus = s => decodeURIComponent(String(s).replace(/\+/g,' ')).trim();
            const daddr = decodePlus(raw);
  
            // split su "to:" con o senza spazi
            const dests = daddr.split(/\s+to:/i).map(s=>s.trim()).filter(Boolean);
  
            // costruisci /maps/dir// + destinazioni (ignoriamo saddr: vogliamo "//")
            if (dests.length){
              const segs = ['']; // "//" come primo punto
              segs.push(...dests.map(s => encodeURIComponent(s).replace(/%20/g,'+')));
              return 'https://www.google.com/maps/dir/' + segs.join('/');
            }
          }
        }
      }catch{}
  
      return u;
    }

    /* === Avviso POI ambigui per fusioni === */
    function looksAmbiguousPOI(token){
      const t = decodeTok(token).toLowerCase().trim();
      if (!t) return false;
    
      // coordinate
      if (/^-?\d+(?:\.\d+)?\s*,\s*-?\d+(?:\.\d+)?$/.test(t)) return false;
    
      // brand/termini molto generici
      const brands = /^(eni|eni station|bp|q8|esso|ip|tamoil|erg|shell|total|repsol)$/i;
      const generic = /^(bar|hotel|ristorante|pizzeria|autogrill|area di servizio|stazione di servizio|benzinaio)$/i;
    
      if (brands.test(t))  return true;
      if (generic.test(t)) return true;
    
      // token troppo corto (es. "BP")
      if (t.length <= 3)   return true;
    
      return false;
    }

    // true se è un link Google /maps/dir/ con parametri "ricchi" (POI) tipo ?data=...
    // rileva i link Google /maps/dir/ “ricchi” (POI) che è meglio NON toccare
    function isGooglePOILink(urlStr){
      try{
        const U = new URL(urlStr);
        if(!/(^|\.)google\./i.test(U.host)) return false;
        if(!/\/maps\/dir\//i.test(U.pathname)) return false;
    
        // 1) caso più comune: /.../data=!4m... è nel PATH
        if (U.pathname.includes('/data=')) return true;
    
        // 2) alcuni hanno i marker “!” (place id ecc.) dopo /@...
        if (U.pathname.includes('/@') && /!1m\d/i.test(urlStr)) return true;
    
        // 3) place-id esadecimali nel link
        if (/0x[0-9a-f]+:0x[0-9a-f]+/i.test(urlStr)) return true;
    
        // 4) (raro) data come query param
        if (U.searchParams.has('data')) return true;
    
        return false;
      }catch{
        return false;
      }
    }
    function buildGoogleDirURL(parts){
      const arr = parts.slice();
    
      // pulizia: niente stringhe vuote interne
      for (let i = arr.length - 1; i > 0; i--) {
        if (arr[i] === '') arr.splice(i, 1);
      }
      // safety: testa vuota garantita
      if (arr[0] !== '') arr.unshift('');
    
      // costruisci e forza /dir//
      return ensureDirHead('https://www.google.com/maps/dir/' + arr.join('/'));
    }
    function dedupeAdjacent(a){ const out=[]; let prev=null; for(const x of a){ if(x!==prev) out.push(x); prev=x; } return out; }
    function evenSample(inner,need){ if(need<=0)return[]; if(inner.length<=need)return inner.slice(); const out=[]; for(let i=0;i<need;i++){ const idx=Math.round(i*(inner.length-1)/(need-1)); out.push(inner[idx]); } const res=[]; for(const v of out){ if(res[res.length-1]!==v) res.push(v); } while(res.length>need) res.pop(); return res; }
    function optimizeTo25(all){ if(all.length<=25) return all; const first=all[0], last=all[all.length-1]; const mid=all.slice(1,all.length-1); const sampled=evenSample(mid,23); return [first,...sampled,last].slice(0,25); }
    function splitInBlocks(all){ const MAX=25, blocks=[]; let rest=all.slice(), first=true; while(rest.length){ const chunk=rest.slice(0,MAX); if(!first && chunk[0]==="") chunk.shift(); blocks.push(chunk); rest=rest.slice(MAX); first=false; } return blocks; }

    function renderOutput(urls){
      const out=document.getElementById('output'),stats=document.getElementById('stats'); out.innerHTML='';
      if(!urls.length){ stats.textContent='Nessun risultato.'; document.getElementById('btnDownloadAll').style.display='none'; return; }
      const n=urls.length; stats.textContent=(n===1?'1 link generato':`${n} link generati`)+` · aggiornato alle ${timeHHMMSS()}`;
      urls.forEach(u=>{
        const div=document.createElement('div'); div.className='out-item';
        div.innerHTML=`<div style="display:flex;justify-content:space-between;gap:10px;align-items:center;">
            <div class="mono" style="flex:1 1 auto;">${u}</div>
            <div class="row" style="flex:0 0 auto;">
              <button class="btn small ghost" data-copy>Copia</button>
              <button class="btn small" data-open>Apri</button>
            </div>
          </div>`;
        div.querySelector('[data-copy]').addEventListener('click',async()=>{await navigator.clipboard.writeText(u);toast('URL copiato')});
        div.querySelector('[data-open]').addEventListener('click',async()=>{const ok=await confirmAction('Aprire il link in una nuova scheda?'); if(ok) window.open(u,'_blank','noopener')});
        out.appendChild(div);
      });
      document.getElementById('btnDownloadAll').style.display='';
      toastCenter(`Risultati aggiornati (${n} link)`);
    }

    document.getElementById('btnMerge').addEventListener('click', async ()=>{
      const lines = document.getElementById('linksInput').value
        .split('\n').map(s=>s.trim()).filter(Boolean);
    
      if(!lines.length){
        toastCenter('Inserisci almeno un link');
        return;
      }
    
      // Caso 1 link con // => errore (coerente con PS)
      if(lines.length===1 && /https?:\/\/[^/]*google\.[^/]+\/maps\/dir\/\//i.test(lines[0])){
        toastCenter('Errore: almeno due link sono necessari per la fusione.');
        return;
      }
    
      // === PATCH: 1 solo link → preserva il link così com'è (niente rebuild) ===
      // --- 1 solo link: apriamo così com'è (niente ricostruzione), con avviso se è un link POI ---
      if (lines.length === 1){
        const u = await resolveIfShort(lines[0]); // segue eventuale shortlink
        if (isGooglePOILink(u)) {
          toastCenter('Link Google con POI/parametri speciali rilevato: lo apro così com’è. Consiglio: usa coordinate/indirizzi se vuoi massima stabilità o aggiungere "La tua posizione".');
        }
        renderOutput([u]);
        return;
      }
    
      // === Da qui in poi: FUSIONE VERA (2+ link) ===
      // Risolvi shortlink su ogni riga (maps.app.goo.gl / goo.gl / g.co)
      // Risolvi shortlink
      const resolved = [];
      for (const ln of lines){ resolved.push(await resolveIfShort(ln)); }
      
      // Avviso se fra gli input ci sono link POI (potrebbero fondersi male)
      if (resolved.some(isGooglePOILink)) {
        toastCenter('Attenzione: tra i link ci sono POI Google (?data=…). La fusione può produrre risultati inattesi. Meglio usare coordinate o indirizzi puliti.');
      }
      
      // Estrai segmenti /maps/dir/
      const clean = [];
      for (const link of resolved){
        const seg = extractDirSegment(link);
        if (seg) clean.push(seg);
      }

      if(!clean.length){
        toastCenter('Nessun link valido "/maps/dir/..." rilevato');
        return;
      }
    
      // Avviso se compaiono POI ambigui tra i token
      (function(){
        const toks = [];
        for(const seg of clean){
          for(const p of seg.split('/')) if(p!=='') toks.push(p);
        }
        if (toks.some(looksAmbiguousPOI)){
          toastCenter('Attenzione: rilevati POI generici (es. ENI/BP). La fusione può spostare i punti: meglio usare coordinate o indirizzi completi.');
        }
      })();
    
      // Costruisci punti con blank iniziale
      // Costruisci punti con blank iniziale garantito
      let all = [''];
      for (const seg of clean){
        // evito empty interni e tengo il mio blank di testa
        all.push(...seg.split('/').filter(Boolean));
      }
      all = dedupeAdjacent(all);
      
      // safety: se per qualunque motivo abbiamo perso il blank, rimettilo
      if (all[0] !== '') all.unshift('');
    
      if(all.length<=25){
        renderOutput(['https://www.google.com/maps/dir/'+all.join('/')]);
        return;
      }
    
      // Strategia >25 punti
      const dlg = document.getElementById('strategyDialog');
      dlg.showModal();
      const strategy = await new Promise(r => dlg.addEventListener(
        'close', ()=>r(dlg.returnValue==='opt'?'optimize':dlg.returnValue==='split'?'split':null),
        {once:true}
      ));
      if(!strategy){
        toastCenter('Operazione annullata');
        return;
      }
      if(strategy==='optimize'){
        renderOutput(['https://www.google.com/maps/dir/'+optimizeTo25(all).join('/')]);
      }else{
        const blocks = splitInBlocks(all);
        renderOutput(blocks.map(b=>'https://www.google.com/maps/dir/'+b.join('/')));
      }
    });
    
    document.getElementById('btnClear').addEventListener('click',()=>{
      document.getElementById('linksInput').value='';
      document.getElementById('output').innerHTML='';
      document.getElementById('stats').textContent='Pulito.';
      document.getElementById('btnDownloadAll').style.display='none';
    });

    document.getElementById('btnDownloadAll').addEventListener('click',async()=>{
      const items=[...document.querySelectorAll('#output .out-item .mono')].map(x=>x.textContent);
      if(!items.length) return;
      const ok=await confirmAction('Scaricare un file .txt con i link generati?'); if(!ok) return;
      const name=(items.length===1?`merge_1_${nowStamp()}.txt`:`merge_${items.length}_${nowStamp()}.txt`);
      const sep=items.length>1?'\n\n':'\n';
      const bytes=new TextEncoder().encode(items.join(sep));
      const url=URL.createObjectURL(new Blob([bytes],{type:'text/plain'}));
      const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      toast('File scaricato');
    });

    /* ===== TAB 2: Maps -> GPX (RTE & TRK + WPT) ===== */
    function extractDirSegmentKeepLeading(s){
      const norm = seg => seg.split('/@')[0].split('?')[0].replace(/\/+$/,'');
      try{
        const m = new URL(s.trim()).pathname.match(/\/maps\/dir\/(.+)/i);
        return m ? norm(m[1]) : null;
      }catch{
        const m = s.trim().match(/\/maps\/dir\/(.+)/i);
        return m ? norm(m[1]) : null;
      }
    }

    function isLatLonStr(s){ const m=s.trim().match(/^(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)$/); return m?{lat:m[1],lon:m[2]}:null; }
    async function geocodeTry(q){ try{ const r=await getJSON(`${CONFIG.workerBase}/geocode?q=${encodeURIComponent(q)}`); if(Array.isArray(r)&&r.length) return r[0]; }catch{} return null; }

    // === CLONE PS 1:1 ===
    // - niente fallback ", Italia" o head trimming
    // - lat/lon già arrotondati a 6 decimali qui
    // Geocoding "strict": SOLO da /dir/; accetto il risultato se il nome combacia col token.
    // Unico fallback per località: aggiungo ", Italia" se il token non contiene già il paese.
    // Geocoding "strict": pochi tentativi, sempre verificando il nome trovato
    async function geocodeFreeform(t){
      // coordinate già pronte?
      const ll = isLatLonStr(t);
      if (ll) {
        return { lat: fmt6s(ll.lat), lon: fmt6s(ll.lon), label: `${fmt6s(ll.lat)},${fmt6s(ll.lon)}` };
      }
    
      // --- SALVAGENTE MIRATO: GRIMSEL ---
      // intercetta qualsiasi variazione che contenga "grimsel"
      const tNorm = normStr(t);
      if (/\bgrimsel\b/.test(tNorm)) {
        // coordinate del passo (centro strada) – stabili
        return { lat: fmt6s('46.5614'), lon: fmt6s('8.33758'), label: 'Grimselpass, Svizzera' };
      }
    
      // geocoding "secco"
      const tryOne = async (q) => {
        const g = await geocodeTry(q);
        if (!g) return null;
        const name = g.display_name || '';
        if (nameMatchesToken(t, name)) {
          return { lat: fmt6s(g.lat), lon: fmt6s(g.lon), label: name };
        }
        return null;
      };
    
      // 1) query originale
      let r = await tryOne(t);
      if (r) return r;
    
      // 2) con sinonimi normalizzati
      const qSyn = applySynonyms(tNorm);      // es. "passo del grimsel" -> "grimsel"
      r = await tryOne(qSyn);
      if (r) return r;
    
      // 3) testa la sola "head" (es. "Bellagio" da "Bellagio, CO")
      const head = t.split(',')[0]?.trim();
      if (head && head.length >= 3) {
        r = await tryOne(head);
        if (r) return r;
      }
    
      // NIENTE fallback su POI generici (p.es. "Orrido di Bracca"): li saltiamo di proposito
      return null;
    }

    async function reverseShortLabel(lat,lon){
      try{
        const r=await getJSON(`${CONFIG.workerBase}/reverse?lat=${lat}&lon=${lon}`);
        const a=r&&r.address?r.address:{};
        const city=a.city||a.town||a.village||a.hamlet||'';
        const prov=a.state_district||a.county||'';
        if(city) return prov?`${city} (${prov})`:city;
      }catch{}
      return 'Località';
    }

    function buildGPX_RTE_WPT(points, steps, title){
      const L=[];
      L.push('<?xml version="1.0" encoding="UTF-8"?>');
      L.push('<gpx version="1.1" creator="MAPS2GPX OSRM" xmlns="http://www.topografix.com/GPX/1/1">');
      L.push(`  <metadata><time>${new Date().toISOString()}</time></metadata>`);
      for(let i=0;i<points.length;i++){
        const p=points[i],lat=fmt6s(p.lat),lon=fmt6s(p.lon),name='WP'+String(i+1).padStart(2,'0');
        const desc=p.label?xmlEscape(p.label):`${lat},${lon}`;
        L.push(`  <wpt lat="${lat}" lon="${lon}"><name>${name}</name><desc>${desc}</desc></wpt>`);
      }
      L.push('  <rte><name>'+xmlEscape(title)+'</name>');
      for(const s of steps){
        const lat=fmt6s(s.lat),lon=fmt6s(s.lon),lab=xmlEscape(s.type||'via');
        L.push(`    <rtept lat="${lat}" lon="${lon}"><name>${lab}</name></rtept>`);
      }
      L.push('  </rte>');
      L.push('</gpx>');
      return joinLF(L) + '\n'; // newline finale come PS
    }
    function buildGPX_TRK_WPT(points, trkCoords, title){
      const L=[];
      L.push('<?xml version="1.0" encoding="UTF-8"?>');
      L.push('<gpx version="1.1" creator="MAPS2GPX OSRM" xmlns="http://www.topografix.com/GPX/1/1">');
      L.push(`  <metadata><time>${new Date().toISOString()}</time></metadata>`);
      for(let i=0;i<points.length;i++){
        const p=points[i],lat=fmt6s(p.lat),lon=fmt6s(p.lon),name='WP'+String(i+1).padStart(2,'0');
        const desc=p.label?xmlEscape(p.label):`${lat},${lon}`;
        L.push(`  <wpt lat="${lat}" lon="${lon}"><name>${name}</name><desc>${desc}</desc></wpt>`);
      }
      L.push('  <trk><name>'+xmlEscape(title)+'</name><trkseg>');
      for(const c of trkCoords){
        const lon=fmt6s(String(c[0])),lat=fmt6s(String(c[1]));
        L.push(`    <trkpt lat="${lat}" lon="${lon}" />`);
      }
      L.push('  </trkseg></trk>');
      L.push('</gpx>');
      return joinLF(L) + '\n'; // newline finale come PS
    }

    let gpxRTE=null,gpxTRK=null,nameRTE='',nameTRK='';
    function resetMaps2GPXUI(){
      document.getElementById('stats2').textContent='Nessun file generato.';
      document.getElementById('gpxPreviewRte').textContent='';
      document.getElementById('gpxPreviewTrk').textContent='';
      document.getElementById('previewWrapRte').hidden=true;
      document.getElementById('previewWrapTrk').hidden=true;
      document.getElementById('dlRow').style.display='none';
      gpxRTE=gpxTRK=null; nameRTE=nameTRK='';
    }

    document.getElementById('btnGenGPX').addEventListener('click', async ()=>{
      resetMaps2GPXUI();
      const raw=document.getElementById('maps2gpxInput').value.split('\n').map(s=>s.trim()).filter(Boolean);
      if(!raw.length){toastCenter('Inserisci almeno una riga');return}

      // Tokenize (salta //)
      let tokens=[];
      for(const line of raw){
        if(/^https?:\/\//i.test(line)){
          const resolved=await resolveIfShort(line);
          const seg=extractDirSegmentKeepLeading(resolved);
          if(!seg){toastCenter('Link non valido: manca /maps/dir/');return;}
          let parts=seg.split('/'); 
          parts=parts.filter(x=>x!==''); 
          parts=parts.map(decodeTok).filter(Boolean);
          tokens.push(...parts);
        }else{
          if(line!=='//') tokens.push(line);
        }
      }
      // Geocoding con salta-errori (1:1 PS)
      const ordered = [], skipped = [], usedFallback = [];  // <-- AGGIUNTO
      for (let i = 0; i < tokens.length; i++) {
        document.getElementById('stats2').textContent = `Geocoding ${i+1}/${tokens.length}...`;
        const tok = tokens[i];
      
        // --- POI hard-coded (match prima del geocode) ---
        let fixed = null;
        for (const poi of POI_FIX) {
          if (poi.match(tok)) { 
            fixed = { lat: poi.lat, lon: poi.lon, label: poi.label };
            // se vuoi conteggiarli come “fallback”, registra il nome
            usedFallback.push(poi.label);                 // <-- facoltativo
            break;
          }
        }
        if (fixed) { ordered.push(fixed); continue; }
      
        const g = await geocodeFreeform(tok);
        if (!g) { skipped.push(tok); continue; }
        ordered.push(g);
      }
      if(ordered.length<2){ document.getElementById('stats2').textContent='Errore: geocoding fallito (troppi pochi punti).'; return; }
      if(skipped.length){ toastCenter(`Saltati ${skipped.length} punto/i non geocodificati: ${skipped.join(' · ')}`); }
      if (usedFallback.length) {
        toastCenter(`Geocodificati con fallback (verifica): ${usedFallback.join(' · ')}`);
      }
      // OSRM con coppie lon,lat ARROTONDATE A 6 (come PS)
      const coordsParam = ordered.map(p => `${p.lon},${p.lat}`).join(';');
      // radius fisso per ogni punto (metri) — solo per questo test
      //const radiusesParam = new Array(ordered.length).fill(1000).join(';');
      //const osrmUrl =
        //`${CONFIG.workerBase}/osrm?coords=${encodeURIComponent(coordsParam)}` +
        //`&profile=driving&overview=full&geometries=geojson&steps=true` +
        //`&radiuses=${encodeURIComponent(radiusesParam)}`;
      const osrmUrl =
        `${CONFIG.workerBase}/osrm?coords=${encodeURIComponent(coordsParam)}` +
        `&profile=driving&overview=full&geometries=geojson&steps=true`;
      document.getElementById('stats2').textContent='Calcolo rotta (OSRM)...';
      let osrm; try{ osrm=await getJSON(osrmUrl); }catch(e){ toastCenter('Errore OSRM'); document.getElementById('stats2').textContent='Errore: OSRM'; return; }
      if(!osrm || osrm.code!=='Ok' || !osrm.routes || !osrm.routes[0]){ toastCenter('OSRM non ha restituito una rotta valida'); document.getElementById('stats2').textContent='Errore: OSRM'; return; }

      // Steps RTE: includi tutti i maneuver (depart/arrive compresi) con dedup adiacente 1e-7 (1:1 PS)
      const rte=[];
      for(const leg of (osrm.routes[0].legs||[])){
        for(const step of (leg.steps||[])){
          if(step.maneuver && Array.isArray(step.maneuver.location)){
            const lon=String(step.maneuver.location[0]), lat=String(step.maneuver.location[1]);
            if(rte.length){
              const last=rte[rte.length-1];
              if(Math.abs(parseFloat(last.lat)-parseFloat(lat))<1e-7 && Math.abs(parseFloat(last.lon)-parseFloat(lon))<1e-7) continue;
            }
            rte.push({lat,lon,type:String(step.maneuver.type||'')});
          }
        }
      }

      // TRK
      const trk=(osrm.routes[0].geometry && osrm.routes[0].geometry.coordinates)?osrm.routes[0].geometry.coordinates:[];
      const startLabel=fileNameSafe(await reverseShortLabel(ordered[0].lat,ordered[0].lon));
      const endLabel=fileNameSafe(await reverseShortLabel(ordered[ordered.length-1].lat,ordered[ordered.length-1].lon));
      const title=`GPX da: ${startLabel} a: ${endLabel}`;
      const ts=nowStamp();

      gpxRTE=buildGPX_RTE_WPT(ordered,rte,title);
      gpxTRK=buildGPX_TRK_WPT(ordered,trk,title);
      nameRTE=`maps2gpx_osrm_rotta_${startLabel}_${endLabel}_${ts}.gpx`;
      nameTRK=`maps2gpx_osrm_traccia_${startLabel}_${endLabel}_${ts}.gpx`;

      document.getElementById('stats2').textContent=`${ordered.length} punti convertiti (WPT) · RTE ${rte.length} step · TRK ${trk.length} vertici`;

      const prevR=gpxRTE.split('\n').slice(0,200).join('\n'); document.getElementById('gpxPreviewRte').textContent=prevR+(gpxRTE.length>prevR.length?'\n...':''); document.getElementById('previewWrapRte').hidden=false;
      const prevT=gpxTRK.split('\n').slice(0,200).join('\n'); document.getElementById('gpxPreviewTrk').textContent=prevT+(gpxTRK.length>prevT.length?'\n...':''); document.getElementById('previewWrapTrk').hidden=false;
      document.getElementById('dlRow').style.display='';
      toastCenter('GPX RTE & TRK pronti');
    });

    function downloadBlob(name, content, mime){
      // Manteniamo newline finale se presente (PS style)
      const out = content.endsWith('\n') ? content : (content + '\n');
      const bytes=new TextEncoder().encode(out);
      const url=URL.createObjectURL(new Blob([bytes],{type:mime||'application/gpx+xml'}));
      const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }
    document.getElementById('btnDownloadRTE').addEventListener('click',async()=>{ if(!gpxRTE){toastCenter('Nessun GPX RTE');return} const ok=await confirmAction('Scaricare il file GPX della rotta (WPT+RTE)?'); if(!ok)return; downloadBlob(nameRTE||`maps2gpx_rotta_${nowStamp()}.gpx`,gpxRTE,'application/gpx+xml'); toast('Download avviato'); });
    document.getElementById('btnDownloadTRK').addEventListener('click',async()=>{ if(!gpxTRK){toastCenter('Nessun GPX TRK');return} const ok=await confirmAction('Scaricare il file GPX della traccia (WPT+TRK)?'); if(!ok)return; downloadBlob(nameTRK||`maps2gpx_traccia_${nowStamp()}.gpx`,gpxTRK,'application/gpx+xml'); toast('Download avviato'); });
    document.getElementById('btnClear2').addEventListener('click',()=>{ document.getElementById('maps2gpxInput').value=''; resetMaps2GPXUI(); document.getElementById('stats2').textContent='Pulito.'; });

    // ===== TAB 3: GPX -> Google Maps =====
    let gpxParsed = null; // { wpt: [{lat,lon}], rte: [...], trk: [...] }
    
    async function readFileText(file){
      if(!file) return '';
      return await new Promise((res,rej)=>{
        const fr=new FileReader();
        fr.onload=()=>res(String(fr.result||''));
        fr.onerror=()=>rej(fr.error||new Error('read error'));
        fr.readAsText(file);
      });
    }
    
    // selezione robusta indipendente dal namespace
    function getByLocalName(doc, local){
      // Prova diretta
      let arr = Array.from(doc.getElementsByTagName(local));
      // Fallback namespace wildcard
      if(!arr.length && doc.getElementsByTagNameNS){
        try { arr = Array.from(doc.getElementsByTagNameNS('*', local)); } catch {}
      }
      // Estremo fallback: scorri tutto e confronta localName
      if(!arr.length){
        arr = Array.from(doc.getElementsByTagName('*')).filter(el => (el.localName||'').toLowerCase()===local.toLowerCase());
      }
      return arr;
    }
    
    function parseGPXText(xmlText){
      const out = { wpt: [], rte: [], trk: [] };
      if(!xmlText || !xmlText.trim()) return out;
    
      let doc;
      try{
        const p = new DOMParser();
        doc = p.parseFromString(xmlText, 'application/xml');
        const pe = doc.getElementsByTagName('parsererror')[0];
        if(pe) throw new Error('XML non valido');
      }catch{
        return out;
      }
    
      // WPT
      for(const el of getByLocalName(doc,'wpt')){
        const lat = el.getAttribute('lat'), lon = el.getAttribute('lon');
        if(lat!=null && lon!=null) out.wpt.push({lat:fmt6s(lat), lon:fmt6s(lon)});
      }
    
      // RTE (tutte le <rtept> in ordine)
      for(const el of getByLocalName(doc,'rtept')){
        const lat = el.getAttribute('lat'), lon = el.getAttribute('lon');
        if(lat!=null && lon!=null) out.rte.push({lat:fmt6s(lat), lon:fmt6s(lon)});
      }
    
      // TRK (tutti i <trkpt> in ordine)
      for(const el of getByLocalName(doc,'trkpt')){
        const lat = el.getAttribute('lat'), lon = el.getAttribute('lon');
        if(lat!=null && lon!=null) out.trk.push({lat:fmt6s(lat), lon:fmt6s(lon)});
      }
    
      return out;
    }
    
    function partsFromPoints(points){
      // Costruisce array per /maps/dir/ con blank iniziale + "lat,lon"
      // Dedup adiacente su token stringa.
      let all = [''];
      for(const p of points){ all.push(`${p.lat},${p.lon}`); }
      all = dedupeAdjacent(all);
      return all;
    }
    
    function renderOutput3(urls){
      const out = document.getElementById('output3');
      const stats = document.getElementById('stats3');
      out.innerHTML = '';
      if(!urls.length){
        stats.textContent = 'Nessun risultato.';
        document.getElementById('btnDownloadAll3').style.display='none';
        return;
      }
      const n=urls.length;
      stats.textContent = (n===1?'1 link generato':`${n} link generati`) + ` · aggiornato alle ${timeHHMMSS()}`;
      for(const u of urls){
        const div=document.createElement('div'); div.className='out-item';
        div.innerHTML=`<div style="display:flex;justify-content:space-between;gap:10px;align-items:center;">
          <div class="mono" style="flex:1 1 auto;">${u}</div>
          <div class="row" style="flex:0 0 auto;">
            <button class="btn small ghost" data-copy>Copia</button>
            <button class="btn small" data-open>Apri</button>
          </div>
        </div>`;
        div.querySelector('[data-copy]').addEventListener('click', async()=>{
          await navigator.clipboard.writeText(u); toast('URL copiato');
        });
        div.querySelector('[data-open]').addEventListener('click', async()=>{
          const ok=await confirmAction('Aprire il link in una nuova scheda?'); if(ok) window.open(u,'_blank','noopener');
        });
        out.appendChild(div);
      }
      document.getElementById('btnDownloadAll3').style.display='';
      toastCenter(`Risultati aggiornati (${n} link)`);
    }
    
    async function makeLinksFrom(points){
      if(!points || points.length<1){ toastCenter('Servono almeno 1-2 punti'); return; }
    
      let all = partsFromPoints(points); // ['','lat,lon',...]
      if(all.length<=25){ renderOutput3([ ensureDirHead('https://www.google.com/maps/dir/'+all.join('/')) ]); return; }
    
      // Troppi punti: usa la stessa modale del Tab 1
      const dlg=document.getElementById('strategyDialog'); dlg.showModal();
      const strategy=await new Promise(r=>dlg.addEventListener('close',()=>r(dlg.returnValue==='opt'?'optimize':dlg.returnValue==='split'?'split':null),{once:true}));
      if(!strategy){ toastCenter('Operazione annullata'); return; }
    
      if(strategy==='optimize'){
        all = optimizeTo25(all);
        renderOutput3([ ensureDirHead('https://www.google.com/maps/dir/'+all.join('/')) ]);
      }else{
        const blocks = splitInBlocks(all); // solo il primo mantiene "" all'inizio
        renderOutput3(blocks.map(b => ensureDirHead('https://www.google.com/maps/dir/'+b.join('/'))));
      }
    }
    
    function refreshButtonsVisibility(){
      const btns = document.getElementById('whichButtons');
      if(!gpxParsed){ btns.style.display='none'; return; }
      const wptN = (gpxParsed.wpt||[]).length;
      const rteN = (gpxParsed.rte||[]).length;
      const trkN = (gpxParsed.trk||[]).length;
      // Mostra contenitore se c'è almeno un set con >=2 punti utili
      const any = (wptN>=2) || (rteN>=2) || (trkN>=2);
      btns.style.display = any ? '' : 'none';
    
      const bW=document.getElementById('btnMakeWPT');
      const bR=document.getElementById('btnMakeRTE');
      const bT=document.getElementById('btnMakeTRK');
    
      bW.style.display = wptN?'' : 'none';
      bR.style.display = rteN?'' : 'none';
      bT.style.display = trkN?'' : 'none';
    
      if(wptN) bW.textContent = `Crea link da WPT (${wptN})`;
      if(rteN) bR.textContent = `Crea link da RTE (${rteN})`;
      if(trkN) bT.textContent = `Crea link da TRK (${trkN})`;
    }
    
    document.getElementById('btnParseGPX').addEventListener('click', async ()=>{
      const file = document.getElementById('gpxFile').files[0]||null;
      const pasted = document.getElementById('gpxText').value;
    
      let text = pasted && pasted.trim() ? pasted : '';
      if(!text && file){
        try{ text = await readFileText(file); }catch{ toastCenter('Errore lettura file'); return; }
      }
      if(!text){ toastCenter('Seleziona un file GPX o incolla il contenuto.'); return; }
    
      gpxParsed = parseGPXText(text);
      const w=(gpxParsed.wpt||[]).length, r=(gpxParsed.rte||[]).length, t=(gpxParsed.trk||[]).length;
      document.getElementById('stats3').textContent = `Trovati: WPT ${w} · RTE ${r} · TRK ${t}`;
      refreshButtonsVisibility();
      document.getElementById('output3').innerHTML='';
      document.getElementById('btnDownloadAll3').style.display='none';
    
      if(w<2 && r<2 && t<2){
        toastCenter('Attenzione: meno di 2 punti per tutte le sezioni.');
      }else{
        toastCenter('Analisi GPX completata.');
      }
    });
    
    document.getElementById('btnMakeWPT').addEventListener('click', ()=>{ if(gpxParsed) makeLinksFrom(gpxParsed.wpt); });
    document.getElementById('btnMakeRTE').addEventListener('click', ()=>{ if(gpxParsed) makeLinksFrom(gpxParsed.rte); });
    document.getElementById('btnMakeTRK').addEventListener('click', ()=>{ if(gpxParsed) makeLinksFrom(gpxParsed.trk); });
    
    document.getElementById('btnDownloadAll3').addEventListener('click', async ()=>{
      const items=[...document.querySelectorAll('#output3 .out-item .mono')].map(x=>x.textContent);
      if(!items.length) return;
      const ok=await confirmAction('Scaricare un file .txt con i link generati?'); if(!ok) return;
      const name=(items.length===1?`gpx2maps_1_${nowStamp()}.txt`:`gpx2maps_${items.length}_${nowStamp()}.txt`);
      const sep=items.length>1?'\n\n':'\n';
      const bytes=new TextEncoder().encode(items.join(sep));
      const url=URL.createObjectURL(new Blob([bytes],{type:'text/plain'}));
      const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      toast('File scaricato');
    });
    
    document.getElementById('btnClear3').addEventListener('click', ()=>{
      document.getElementById('gpxFile').value='';
      document.getElementById('gpxText').value='';
      document.getElementById('stats3').textContent='Pulito.';
      document.getElementById('output3').innerHTML='';
      document.getElementById('btnDownloadAll3').style.display='none';
      document.getElementById('whichButtons').style.display='none';
      gpxParsed=null;
    });

    // ===== TAB 4: Sanitizza GPX =====
    (function(){
      const $in  = ()=>document.getElementById('sanitizeInput');
      const $f   = ()=>document.getElementById('sanitizeFile');
      const $st  = ()=>document.getElementById('stats4');
      const $preW= ()=>document.getElementById('previewWrapSan');
      const $pre = ()=>document.getElementById('gpxPreviewSan');
      const $dlW = ()=>document.getElementById('dlRow4');
      const $btnDl=()=>document.getElementById('btnDownloadSan');
    
      let sanitizedText = '';
      let sanitizedName = '';
    
      function resetSanUI(){
        $st().textContent='Nessun file sanificato.';
        $pre().textContent='';
        $preW().hidden=true;
        $dlW().style.display='none';
        sanitizedText='';
        sanitizedName='';
      }
    
      // Core: arrotonda lat/lon, dedupe adiacente, LF only, UTF-8 on download
      function sanitizeGPX(raw){
        // forza LF e rimuove eventuale BOM
        let txt = String(raw).replace(/^\uFEFF/, '').replace(/\r\n?/g, '\n');
    
        // parse XML
        const parser = new DOMParser();
        const doc = parser.parseFromString(txt, 'application/xml');
        if(doc.querySelector('parsererror')){
          throw new Error('XML non valido (parsererror)');
        }
        const root = doc.documentElement;
        if(!root || root.nodeName.toLowerCase()!=='gpx') throw new Error('File non GPX');
    
        const stats = {
          wpt:0, rtept:0, trkpt:0,
          normalized:0,
          dropped:{ wpt:0, rtept:0, trkpt:0 }
        };
    
        // arrotonda attributi lat/lon
        function roundLatLon(el){
          const hasLat = el.hasAttribute('lat');
          const hasLon = el.hasAttribute('lon');
          if(!hasLat || !hasLon) return false;
          const latRaw = el.getAttribute('lat');
          const lonRaw = el.getAttribute('lon');
          // normalizza numeri strani
          const toNum = v => {
            const s = String(v).trim().replace(',', '.');
            const n = Number(s);
            return isFinite(n) ? n : NaN;
          };
          const latNum = toNum(latRaw);
          const lonNum = toNum(lonRaw);
          if(isNaN(latNum) || isNaN(lonNum)) return false;
    
          const lat = fmt6s(latNum);
          const lon = fmt6s(lonNum);
    
          if(el.getAttribute('lat')!==lat){ el.setAttribute('lat', lat); stats.normalized++; }
          if(el.getAttribute('lon')!==lon){ el.setAttribute('lon', lon); stats.normalized++; }
          return true;
        }
    
        // conta e round su wpt/rtept/trkpt
        const wpts = Array.from(doc.getElementsByTagName('wpt'));
        wpts.forEach(el=>{ stats.wpt++; roundLatLon(el); });
    
        const rtes = Array.from(doc.getElementsByTagName('rte'));
        rtes.forEach(rte=>{
          const pts = Array.from(rte.getElementsByTagName('rtept'));
          pts.forEach(el=>{ stats.rtept++; roundLatLon(el); });
        });
    
        const trks = Array.from(doc.getElementsByTagName('trk'));
        trks.forEach(trk=>{
          const segs = Array.from(trk.getElementsByTagName('trkseg'));
          segs.forEach(seg=>{
            const pts = Array.from(seg.getElementsByTagName('trkpt'));
            pts.forEach(el=>{ stats.trkpt++; roundLatLon(el); });
          });
        });
    
        // dedupe adiacente conservativo
        function dedupeAdjacent(list, kind, parent){
          if(list.length<=1) return;
          let prev = list[0];
          for(let i=1;i<list.length;i++){
            const cur = list[i];
            const same = prev.getAttribute('lat')===cur.getAttribute('lat')
                      && prev.getAttribute('lon')===cur.getAttribute('lon');
            if(same){
              parent.removeChild(cur);
              stats.dropped[kind]++;
            }else{
              prev = cur;
            }
          }
        }
    
        // WPT: dedupe solo su sequenze adiacenti a livello root
        {
          const children = Array.from(root.children);
          let run = [];
          for(const ch of children){
            if(ch.tagName && ch.tagName.toLowerCase()==='wpt') run.push(ch);
            else{
              if(run.length) dedupeAdjacent(run, 'wpt', root);
              run = [];
            }
          }
          if(run.length) dedupeAdjacent(run, 'wpt', root);
        }
    
        // RTE: per ogni rte, dedupe sulla lista diretta di rtept
        rtes.forEach(rte=>{
          const pts = Array.from(rte.children).filter(n=>n.tagName && n.tagName.toLowerCase()==='rtept');
          if(pts.length) dedupeAdjacent(pts, 'rtept', rte);
        });
    
        // TRK: per ogni trkseg, dedupe sulla lista diretta di trkpt
        trks.forEach(trk=>{
          const segs = Array.from(trk.getElementsByTagName('trkseg'));
          segs.forEach(seg=>{
            const pts = Array.from(seg.children).filter(n=>n.tagName && n.tagName.toLowerCase()==='trkpt');
            if(pts.length) dedupeAdjacent(pts, 'trkpt', seg);
          });
        });
    
        // Serializza, forza intestazione XML UTF-8, LF-only, newline finale
        let body = new XMLSerializer().serializeToString(doc);
        body = body.replace(/^\s*<\?xml[\s\S]*?\?>\s*/,''); // togli eventuale vecchia declaration
        let out = `<?xml version="1.0" encoding="UTF-8"?>\n` + body;
        out = out.replace(/\r\n?/g, '\n');
        if(!out.endsWith('\n')) out += '\n';
    
        return { text: out, stats };
      }
    
      // UI handlers
      document.getElementById('btnSanitize').addEventListener('click', ()=>{
        const raw = $in().value.trim();
        if(!raw){ toastCenter('Incolla un GPX o apri un file'); return; }
        try{
          const {text, stats} = sanitizeGPX(raw);
          sanitizedText = text;
          sanitizedName = `gpx_sanitizzato_${nowStamp()}.gpx`;
    
          $st().textContent =
            `WPT ${stats.wpt} · RTEPT ${stats.rtept} · TRKPT ${stats.trkpt} · `+
            `Normalizzati ${stats.normalized} · Duplicati rimossi: `+
            `WPT ${stats.dropped.wpt}, RTE ${stats.dropped.rtept}, TRK ${stats.dropped.trkpt}`;
          const prev = text.split('\n').slice(0,200).join('\n');
          $pre().textContent = prev + (text.length>prev.length?'\n...':'');
          $preW().hidden = false;
          $dlW().style.display = '';
          toastCenter('Sanitizzazione completata (LF + UTF-8)');
        }catch(e){
          console.error(e);
          toastCenter('Errore di parsing GPX: verifica il file');
          resetSanUI();
        }
      });
    
      document.getElementById('btnDownloadSan').addEventListener('click', async ()=>{
        if(!sanitizedText){ toastCenter('Nessun file sanificato'); return; }
        const ok = await confirmAction('Scaricare il file GPX sanificato?');
        if(!ok) return;
        // Forziamo charset UTF-8; LF già garantito dal testo
        const bytes = new TextEncoder().encode(sanitizedText.endsWith('\n') ? sanitizedText : (sanitizedText+'\n'));
        const url = URL.createObjectURL(new Blob([bytes], {type:'application/gpx+xml; charset=utf-8'}));
        const a=document.createElement('a'); a.href=url; a.download=(sanitizedName||`gpx_sanitizzato_${nowStamp()}.gpx`);
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
        toastCenter('Download avviato');
      });
    
      document.getElementById('btnClear4').addEventListener('click', ()=>{
        $in().value=''; $f().value=''; resetSanUI(); $st().textContent='Pulito.';
      });
    
      document.getElementById('sanitizeFile').addEventListener('change', async (e)=>{
        const file = e.target.files && e.target.files[0];
        if(!file) return;
        const txt = await file.text(); // UTF-8 by default
        $in().value = txt;
        toastCenter(`Caricato: ${file.name}`);
      });
    })();
    /* ===== TAB 5: Meteo + Info percorso =====
     - 1 link maps o lista libera
     - WPT esclusivamente da /dir/ ... /@ (se link)
     - Geocoding -> OSRM per distanze/tempi (parziali & totali)
     - Weather via Open-Meteo (tramite worker /weather)
     - Genera 3 file: HTML (tabella PS), TXT (info percorso) e CSV
     - Etichette UI: “Meteo”, “Info Percorso TXT”, “Info Percorso CSV”
     - Apri: solo HTML+TXT; CSV solo scarica
     - Solo LF, UTF-8
  */
  (function(){
    const $in   = document.getElementById('meteoInput');
    const $out  = document.getElementById('meteoOut');
    const $list = document.getElementById('meteoFiles');
  
    function clearUI(){
      $out.querySelector('.note').textContent = 'Nessun file generato.';
      $list.innerHTML = '';
    }
    document.getElementById('btnClearMeteo').addEventListener('click',()=>{ $in.value=''; clearUI(); });
  
    // Reuse helpers from Tabs 1-2
    function decodeTokPlus(s){ try{return decodeURIComponent(String(s).replace(/\+/g,' ')).trim()}catch{return String(s).replace(/\+/g,' ').trim()} }
  
    function segmentDirOnly(u){
      // ritorna solo la porzione tra /maps/dir/ e prima di /@ o ?data=
      const m = stripAtTail(u).match(/^https?:\/\/[^/]*google\.[^/]+\/maps\/dir\/(.+)$/i);
      if(!m) return null;
      return m[1].replace(/\/+$/,'');
    }
  
    // “//” -> prompt prima località (solo per long link con blank head)
    async function tokensFromInput(lines){
      let tokens = [];
      if(lines.length===1 && /^https?:\/\//i.test(lines[0])){
        const resolved = await resolveForMeteo(lines[0]);
        const seg = segmentDirOnly(resolved);
        if(!seg){ throw new Error('Link non valido: manca /maps/dir/'); }
        let parts = seg.split('/');
        // se il primo è vuoto => chiedi località
        if(parts[0]===''){
          const first = window.prompt('Il link ha la prima posizione vuota. Inserisci la prima località in formato città e provincia per esteso anche in minuscolo. Esempio: arluno milano:','');
          if(!first) throw new Error('Operazione annullata: prima località mancante');
          parts[0] = encodeURIComponent(first).replace(/%20/g,'+');
        }
        parts = parts.filter(x=>x!=='').map(decodeTokPlus).filter(Boolean);
        tokens = parts;
      }else{
        // lista manuale
        for(const ln of lines){ if(ln!=='//') tokens.push(ln); }
      }
      if(tokens.length<2) throw new Error('Servono almeno 2 punti');
      return tokens;
    }
  
    function itKm(x){ return fmt6s(+x/1000).replace('.',','); } // metri->km con virgola (string)
    function it1(x){ return String(Math.round(+x*10)/10).replace('.',','); } // 1 decimale con virgola
    function toHM(sec){
      sec = Math.round(sec||0);
      const h = Math.floor(sec/3600), m = Math.round((sec%3600)/60);
      return `${h} h ${m} m`;
    }
  
    // Geocoding (riuso Tab2)
    async function geocodeList(ts){
      const ordered=[], skipped=[];
      for(let i=0;i<ts.length;i++){
        $out.querySelector('.note').textContent = `Geocoding ${i+1}/${ts.length}...`;
        const g = await geocodeFreeform(ts[i]);
        if(!g) skipped.push(ts[i]); else ordered.push(g);
      }
      return {ordered, skipped};
    }
  
    async function reverseShortLocal(lat,lon){
      const label = await reverseShortLabel(lat,lon);
      // niente coordinate nei file: solo label “Città (Prov)”
      return label || 'Località';
    }
  
    // === Open-Meteo tramite worker ===
    async function fetchWeather(lat,lon){
      const u = `${CONFIG.workerBase}/weather?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&days=7`;
      const j = await getJSON(u);
      return j||null;
    }
  
    // Mappa weathercode -> tipo base (per icone & severità)
    function wxKind(code){
      code = +code;
      if([0].includes(code)) return 'clear';
      if([1,2].includes(code)) return 'partly';
      if([3].includes(code)) return 'cloudy';
      if([45,48].includes(code)) return 'fog';
      if([51,53,55,56,57,61,63,65,66,67,80,81,82].includes(code)) return 'rain';
      if([71,73,75,77,85,86].includes(code)) return 'snow';
      if([95,96,99].includes(code)) return 'storm';
      return 'cloudy';
    }
  
    // icone inline – stesse del sample PS (semplificate)
    const ICONS = {
      clear: `<g stroke="#CC9A06" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="24" cy="24" r="9" fill="#FDB813" stroke="#E0A106"/>
        <line x1="24" y1="3" x2="24" y2="11" stroke="#FFC107"/>
        <line x1="24" y1="37" x2="24" y2="45" stroke="#FFC107"/>
        <line x1="3"  y1="24" x2="11" y2="24" stroke="#FFC107"/>
        <line x1="37" y1="24" x2="45" y2="24" stroke="#FFC107"/>
        <line x1="10" y1="10" x2="15" y2="15" stroke="#FFC107"/>
        <line x1="33" y1="33" x2="38" y2="38" stroke="#FFC107"/>
        <line x1="10" y1="38" x2="15" y2="33" stroke="#FFC107"/>
        <line x1="33" y1="15" x2="38" y2="10" stroke="#FFC107"/>
      </g>`,
      partly: `<g fill="none" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="18" cy="20" r="7" fill="#FDB813" stroke="#E0A106" stroke-width="2"/>
        <path d="M28 32h8a8 8 0 0 0 0-16a9 9 0 0 0-7.5 4.2" fill="#E6E9EF" stroke="#8A97A6" stroke-width="2"/>
      </g>`,
      cloudy: `<path d="M12 32h22a8 8 0 0 0 0-16a10 10 0 0 0-19 3" fill="#E6E9EF" stroke="#8A97A6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`,
      rain: `<path d="M12 28h22a8 8 0 0 0 0-16a10 10 0 0 0-19 3" fill="#E6E9EF" stroke="#8A97A6" stroke-width="2"/>
        <g stroke="#2196F3" stroke-width="2" stroke-linecap="round">
          <line x1="16" y1="34" x2="16" y2="42"/><line x1="24" y1="34" x2="24" y2="42"/><line x1="32" y1="34" x2="32" y2="42"/>
        </g>`,
      showers:`<path d="M12 28h22a8 8 0 0 0 0-16a10 10 0 0 0-19 3" fill="#E6E9EF" stroke="#8A97A6" stroke-width="2"/>
        <circle cx="16" cy="38" r="2" fill="#4FC3F7"/><circle cx="24" cy="38" r="2" fill="#4FC3F7"/><circle cx="32" cy="38" r="2" fill="#4FC3F7"/>`,
      storm: `<path d="M12 28h22a8 8 0 0 0 0-16a10 10 0 0 0-19 3" fill="#E6E9EF" stroke="#8A97A6" stroke-width="2"/>
        <path d="M22 30l-4 8h6l-2 8l8-12h-6l2-4z" fill="#FFEB3B" stroke="#CC9A06" stroke-width="1"/>`,
      fog: `<path d="M10 20h28M8 26h32M12 32h24" stroke="#94A3B8" stroke-width="2" stroke-linecap="round"/>`,
      snow:`<path d="M12 28h22a8 8 0 0 0 0-16a10 10 0 0 0-19 3" fill="#E6E9EF" stroke="#8A97A6" stroke-width="2"/>
        <g stroke="#90CAF9" stroke-width="2" stroke-linecap="round">
          <line x1="16" y1="34" x2="16" y2="40"/><line x1="14" y1="36" x2="18" y2="38"/><line x1="18" y1="36" x2="14" y2="38"/>
          <line x1="24" y1="34" x2="24" y2="40"/><line x1="22" y1="36" x2="26" y2="38"/><line x1="26" y1="36" x2="22" y2="38"/>
          <line x1="32" y1="34" x2="32" y2="40"/><line x1="30" y1="36" x2="34" y2="38"/><line x1="34" y1="36" x2="30" y2="38"/>
        </g>`
    };
  
    function svg(kind){ return `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48' width='24' height='24' role='img'>${ICONS[kind]||ICONS.cloudy}</svg>`; }
  
    // Classe cella: rosso (wx-bad) se prob precip alta o tempesta; giallo (wx-mid) se coperto/variabile
    function cellClass(kind, maxProb){
      if(kind==='storm') return 'wx-bad';
      if(['rain','snow'].includes(kind) && maxProb>=40) return 'wx-bad';
      if(kind==='cloudy' || kind==='fog' || (['rain','snow'].includes(kind) && maxProb>0)) return 'wx-mid';
      return '';
    }
  
    // Aggrega 7 giorni x 4 fasce da hourly
    function build7x4(weather){
      // fasce: 0-6 (Notte), 6-12 (Mattino), 12-18 (Pomeriggio), 18-24 (Sera)
      const times = weather.hourly.time; // ISO in timezone localizzato
      const T     = weather.hourly.temperature_2m;
      const P     = weather.hourly.precipitation_probability || T.map(()=>0);
      const W     = weather.hourly.weathercode;
      // giorni (etichette dall'array daily.time)
      const days  = weather.daily.time.slice(0,7);
      const dMin  = weather.daily.temperature_2m_min.slice(0,7);
      const dMax  = weather.daily.temperature_2m_max.slice(0,7);
  
      // indice orario -> dayIdx + slotIdx
      const byDaySlot = days.map(()=>[[],[],[],[]]); // 7 x 4 array
      for(let i=0;i<times.length;i++){
        const dayStr = times[i].slice(0,10);
        const dIdx = days.indexOf(dayStr);
        if(dIdx<0 || dIdx>6) continue;
        const h = parseInt(times[i].slice(11,13), 10); // ora locale della località
        const sIdx = (h<6)?0:(h<12)?1:(h<18)?2:3;
        byDaySlot[dIdx][sIdx].push({t:T[i], p:P[i], w:W[i]});
      }
  
      // compact per ogni giorno/slot -> {kind, tempMid, pMax}
      const grid = days.map((d,di)=>{
        return [0,1,2,3].map(si=>{
          const arr = byDaySlot[di][si];
          if(!arr.length) return {kind:'cloudy', temp:NaN, p:0};
          // dominante: il “kind” più frequente
          const freq={}; let maxKind='cloudy',maxN=0,pmax=0, tsum=0;
          for(const x of arr){ const k = wxKind(x.w); freq[k]=(freq[k]||0)+1; if(freq[k]>maxN){maxN=freq[k];maxKind=k} pmax=Math.max(pmax, +x.p||0); tsum+=+x.t; }
          const tavg = tsum/arr.length;
          return {kind:maxKind, temp:tavg, p:pmax};
        });
      });
  
      // etichette colonne (italiano corto) + min/max per title
      const itDays = ['dom','lun','mar','mer','gio','ven','sab'];
      const cols = days.map(ds=>{
        const d = new Date(ds+'T00:00:00'); const dd = String(d.getDate()).padStart(2,'0'); const mm = String(d.getMonth()+1).padStart(2,'0');
        return `${itDays[d.getDay()]} ${dd}/${mm}`;
      });
  
      return {grid, dayLabels:cols, dMin, dMax};
    }
  
    function htmlMeteoWeek(title, rows, dayLabels){
      // rows: [{name, parts:[{day:[{kind,temp,p}], ...7], minmax:[{min,max}...] }...]
      const style = `<style>
      html, body { height:100% }
      body{font-family:Segoe UI,Arial,sans-serif;margin:16px}
      h1{font-size:20px;margin:0 0 8px 0}
      .wrap{border:1px solid #ddd}
      table.wxgrid{width:100%;table-layout:fixed;min-width:760px;border-collapse:separate;border-spacing:0}
      table.wxgrid th,table.wxgrid td{border:1px solid #ddd;padding:6px 8px;text-align:center;font-size:12px;vertical-align:middle}
      table.wxgrid thead th{background:#f5f5f5;font-weight:700;white-space:nowrap}
      table.wxgrid thead tr:nth-child(1) th{position:sticky;top:0;z-index:10;background:#f5f5f5}
      table.wxgrid thead tr:nth-child(2) th{position:sticky;top:34px;z-index:9;background:#f5f5f5;border-bottom:2px solid #999}
      .loccol{min-width:180px;max-width:260px;background:#fafafa;position:sticky;left:0;z-index:11;text-align:left;box-shadow:inset -2px 0 0 #999}
      tbody .loccol{background:#fafafa}
      th.col-day-end,td.col-day-end{box-shadow:inset -2px 0 0 #999}
      th.dayh.day-end{box-shadow:inset -2px 0 0 #999}
      .dayh{min-width:360px}.fasciah{min-width:90px}
      tbody tr:nth-child(odd){background:#fcfcfc}
      tbody tr.loc-start td{border-top:2px solid #999}
      td.wx-bad{background:#ffe5e5}
      td.wx-mid{background:#fff4cc}
      .wx{display:flex;flex-direction:column;align-items:center;gap:2px}
      .wx svg{width:24px;height:24px}
      .wx .t{font-size:11px}
      </style>`;
      
          const fasce = ['Notte','Mattino','Pomeriggio','Sera'];
      
          // head
          let H = `<!DOCTYPE html><html><head><meta charset="utf-8"><title>Meteo percorso</title>${style}</head><body>\n`;
          H += `<h1>${xmlEscape(title)} (7 giorni, 4 fasce)</h1>\n`;
          H += `<div class='wrap'><table id='wx-table' class='wxgrid'>\n<thead><tr><th class='loccol' rowspan='2'>Localita'</th>`;
          for(let i=0;i<7;i++){
            H += `<th class='dayh${i===6?' day-end':''}' colspan='4'>${xmlEscape(dayLabels[i])}</th>`;
          }
          H += `</tr>\n<tr>`;
          for(let i=0;i<7;i++){
            for(let s=0;s<4;s++) H += `<th class='fasciah${(s===3)?' col-day-end':''}'>${fasce[s]}</th>`;
          }
          H += `</tr></thead>\n<tbody>\n`;
      
          // body
          rows.forEach((row,ri)=>{
            H += `<tr class='loc-start'><td class='loccol'>${xmlEscape(row.name)}</td>`;
            for(let d=0;d<7;d++){
              for(let s=0;s<4;s++){
                const cell = row.parts[d][s];
                const mm   = row.minmax[d];
                const title = `min ${it1(mm.min)} / max ${it1(mm.max)}`;
                const cls = cellClass(cell.kind, cell.p);
                H += `<td class='${cls}${(s===3?' col-day-end':'')}' title='${xmlEscape(title)}'><div class='part wx'>${svg(cell.kind)}<div class='t'>${isFinite(cell.temp)?it1(cell.temp):''}</div></div></td>`;
              }
            }
            H += `</tr>\n`;
          });
      
          H += `</tbody></table></div>\n</body></html>`;
          return H;
        }
    
    function htmlMeteoDay(title, rows, dayLabels){
  // Prepara dati 7×4×N partendo da rows (come già calcolate)
  const PHASES = ['Notte','Mattino','Pomeriggio','Sera'];
  const placeNames = rows.map(r=>r.name);
  const fx = dayLabels.map((_, di) =>
    PHASES.map((__, si) =>
      rows.map(r => {
        const c  = (r.parts[di] && r.parts[di][si]) || {kind:'cloudy', p:0, temp:NaN};
        const mm = r.minmax[di] || {min:null, max:null};
        return {
          kind: c.kind,
          prob: +c.p || 0,
          tmin: (mm.min!=null ? it1(mm.min) : null),
          tmax: (mm.max!=null ? it1(mm.max) : null)
        };
      })
    )
  );
  const data = {
    title, dayLabels, placeNames, phases: PHASES, fx,
    generatedAt: new Date().toISOString()
  };

  // JSON sicuro dentro <script type="application/json">
  let payload = JSON.stringify(data);
  payload = payload.replace(/</g,'\\u003C').replace(/<\/script/gi,'<\\/script');
  const gen = data.generatedAt.replace('T',' ').slice(0,16);

  const H = [];
  H.push('<!doctype html>');
  H.push('<html lang="it">');
  H.push('<head>');
  H.push('<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">');
  H.push('<title>'+xmlEscape(title)+' (7 giorni, 4 fasce)</title>');
  H.push('<style>');
  H.push('  :root{--fg:#111827;--muted:#6b7280;--bg:#fff;--border:#e5e7eb;--warn:#fff4cc;--bad:#ffe5e5;--btn:#0ea5e9;--btnText:#fff}');
  H.push('  *{box-sizing:border-box}');
  H.push('  body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}');
  H.push('  header{padding:12px 14px;border-bottom:1px solid var(--border)}');
  H.push('  h1{margin:0 0 4px;font-size:16px;font-weight:800}');
  H.push('  .muted{color:var(--muted);font-size:12px}');
  H.push('  .days{display:flex;gap:8px;padding:10px;overflow:auto;border-bottom:1px solid var(--border)}');
  H.push('  .day-btn{flex:0 0 auto;appearance:none;border:1px solid var(--border);background:#fff;border-radius:999px;padding:6px 10px;font-weight:700;cursor:pointer}');
  H.push('  .day-btn.active{background:var(--btn);color:var(--btnText);border-color:transparent}');
  H.push('  .wrap{padding:10px}');
  H.push('  .tableWrap{border:1px solid var(--border);border-radius:12px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:80vh;background:#fff}');
  H.push('  .grid{display:grid;grid-template-columns:repeat(5,minmax(0,1fr));min-width:0}');
  H.push('  .cell{padding:10px;border-bottom:1px solid var(--border);border-right:1px solid var(--border);background:#fff}');
  H.push('  .cell:last-child{border-right:none}');
  H.push('  .row:last-child .cell{border-bottom:none}');
  H.push('  .th{font-weight:800;background:#fff}');
  H.push('  .sticky-top{position:sticky;top:0;z-index:3}');
  H.push('  .sticky-left{position:sticky;left:0;z-index:2;background:#fff}');
  H.push('  .corner{z-index:4}');
  H.push('  .loc{white-space:normal;word-break:break-word;hyphens:auto;overflow:visible;text-overflow:clip}');
  H.push('  .cell{padding:8px;border-bottom:1px solid var(--border);border-right:1px solid var(--border);background:#fff}');
  H.push('  .warn{background:var(--warn)}');
  H.push('  .bad{background:var(--bad)}');
  /* forza il colore di stato sulle celle, costi quel che costi */
  H.push('  .cell.warn{ background: var(--warn) !important;}');
  H.push('  .cell.bad { background: var(--bad)  !important;}');
  H.push('  .cond{display:flex;align-items:center;gap:6px;justify-content:center}');
  H.push('  .cond .t{font-variant-numeric:tabular-nums}');
  H.push('  footer{padding:10px 14px;color:var(--muted);font-size:12px}');
  H.push('</style>');
  H.push('</head>');
  H.push('<body>');
  H.push('<header>');
  H.push('<h1>Meteo</h1>');
  H.push('<div class="muted">'+xmlEscape(title)+' · Generato: '+xmlEscape(gen)+'</div>');
  H.push('</header>');
  H.push('<div class="days" id="days"></div>');
  H.push('<div class="wrap"><div class="tableWrap"><div id="grid" class="grid" role="table" aria-label="Tabella meteo"></div></div></div>');
  H.push('<footer>Colori: nessuno = buono · giallo = incerto · rosso = brutto.</footer>');
  H.push('<script id="payload" type="application/json">'+payload+'</scr'+'ipt>');
  H.push('<script>(function(){');
  H.push('var elDays=document.getElementById("days");');
  H.push('var elGrid=document.getElementById("grid");');
  H.push('var data=JSON.parse(document.getElementById("payload").textContent);');
  H.push('var PHASES=data.phases||["Notte","Mattino","Pomeriggio","Sera"];');
  H.push('function sev(k,p){if(k==="storm")return "bad";if((k==="rain"||k==="snow")&&p>=40)return "bad";if(k==="cloudy"||k==="fog"||((k==="rain"||k==="snow")&&p>0))return "warn";return "";}');
  H.push('function btn(l,i,a){var b=document.createElement("button");b.className="day-btn"+(a?" active":"");b.textContent=l;b.addEventListener("click",function(){setActive(i);render(i);});return b;}');
  H.push('function setActive(i){Array.prototype.forEach.call(elDays.children,function(n,k){n.classList.toggle("active",k===i);});}');
  H.push('function cell(cls,html){var d=document.createElement("div");d.className="cell "+cls;d.innerHTML=html;return d;}');
  H.push('function iconOf(k){return k==="clear"?"☀️":k==="partly"?"⛅":k==="cloudy"?"☁️":k==="rain"?"🌧":k==="storm"?"⛈":k==="fog"?"🌫":k==="snow"?"❄":"☁️";}');
  H.push('function render(dayIdx){');
  H.push('  elGrid.innerHTML="";');
  H.push('  elGrid.appendChild(cell("th sticky-top sticky-left corner","&nbsp;"));');
  H.push('  for(var p=0;p<PHASES.length;p++){elGrid.appendChild(cell("th sticky-top",PHASES[p]));}');
  H.push('  for(var r=0;r<data.placeNames.length;r++){');
  H.push('    elGrid.appendChild(cell("sticky-left loc",data.placeNames[r]));');
  H.push('    for(var p=0;p<PHASES.length;p++){');
  H.push('      var cur=(data.fx[dayIdx]&&data.fx[dayIdx][p]&&data.fx[dayIdx][p][r])||{kind:"cloudy",prob:0,tmin:null,tmax:null};');
  H.push('      var klass=sev(cur.kind,cur.prob);');
  H.push('      var temp=(cur.tmax!=null&&cur.tmin!=null)?(cur.tmax+"° / "+cur.tmin+"°"):"";');
  H.push('      elGrid.appendChild(cell(klass, \'<div class="cond"><span>\'+iconOf(cur.kind)+\'</span><span class="t">\'+temp+\'</span></div>\'));');
  H.push('    }');
  H.push('  }');
  H.push('}');
  H.push('elDays.innerHTML="";');
  H.push('data.dayLabels.forEach(function(d,i){elDays.appendChild(btn(d,i,i===0));});');
  H.push('setActive(0); render(0);');
  H.push('})();</scr'+'ipt>');
  H.push('</body></html>');
  return H.join('\n');
}
  
    function formatKmIT(km){
      // 1 decimale, ma niente ",0"
      const v = Math.round(km*10)/10;
      const s = Number.isInteger(v) ? String(v) : v.toFixed(1);
      return s.replace('.', ',') + ' km';
    }
    function formatDur(h, m){
      return `${h} h ${m} m`;
    }
    
    // rows: [{idx,name,totKm,totH,totM,parzKm,parzH,parzM}]
    function buildInfoPercorsoTXT(rows, titolo){
      // Calcolo larghezze colonne
      const col1H = 'Punto';
      const col2H = 'Localita';
      const col3H = 'Totale Km';
      const col4H = 'Totale Tempo';
      const col5H = 'Parziale Km';
      const col6H = 'Parziale Tempo';
    
      const col1W = Math.max(col1H.length, ...rows.map(r=>String(r.idx).length));
      const col2W = Math.max(col2H.length, ...rows.map(r=>r.name.length));
      const col3W = Math.max(col3H.length, ...rows.map(r=>formatKmIT(r.totKm).length));
      const col4W = Math.max(col4H.length, ...rows.map(r=>formatDur(r.totH,r.totM).length));
      const col5W = Math.max(col5H.length, ...rows.map(r=>formatKmIT(r.parzKm).length));
      const col6W = Math.max(col6H.length, ...rows.map(r=>formatDur(r.parzH,r.parzM).length));
    
      const sep = ' | ';
      const line = (c1,c2,c3,c4,c5,c6) =>
        c1.padStart(col1W) + sep +
        c2.padEnd(col2W) + sep +
        c3.padStart(col3W) + sep +
        c4.padStart(col4W) + sep +
        c5.padStart(col5W) + sep +
        c6.padStart(col6W);
    
      const dash = (n)=>'-'.repeat(n);
      const header = line(col1H,col2H,col3H,col4H,col5H,col6H);
      const underline = [
        dash(col1W), dash(col2W), dash(col3W), dash(col4W), dash(col5W), dash(col6W)
      ].join(sep);
    
      const lines = [];
      lines.push(`Percorso da: ${titolo.da} a: ${titolo.a}`);
      lines.push(`Punti totali: ${rows.length} | Distanza totale: ${formatKmIT(rows.at(-1).totKm)} | Tempo totale: ${formatDur(rows.at(-1).totH, rows.at(-1).totM)}`);
      lines.push('');
      lines.push(header);
      lines.push(underline);
      for(const r of rows){
        lines.push(line(
          String(r.idx),
          r.name,
          formatKmIT(r.totKm),
          formatDur(r.totH,r.totM),
          formatKmIT(r.parzKm),
          formatDur(r.parzH,r.parzM)
        ));
      }
      return lines.join('\n');
    }

  
    async function buildRouteLegs(points){
      // OSRM full route con legs (driving)
      const coords = points.map(p=>`${p.lon},${p.lat}`).join(';');
      const url = `${CONFIG.workerBase}/osrm?coords=${encodeURIComponent(coords)}&profile=driving&overview=false&geometries=geojson&steps=false`;
      const j = await getJSON(url);
      if(!j || j.code!=='Ok' || !j.routes || !j.routes[0]) throw new Error('OSRM route error');
      const route = j.routes[0];
      const legs = (route.legs||[]).map(L=>({dist:+L.distance||0, dur:+L.duration||0}));
      const totals = {dist:+route.distance||legs.reduce((a,b)=>a+b.dist,0), dur:+route.duration||legs.reduce((a,b)=>a+b.dur,0)};
      return {legs, totals};
    }
  
    function addFileRow(label, blob, fname, canOpen){
      const url = URL.createObjectURL(blob);
      const row = document.createElement('div');
      row.className='row'; row.style.marginTop='8px';
      row.innerHTML = `<div style="flex:1 1 auto;font-weight:700;">${label}</div>
        <div class="row" style="flex:0 0 auto;">
          ${canOpen?'<button class="btn small ghost" data-open>Apri</button>':''}
          <button class="btn small" data-dl>Scarica</button>
        </div>`;
      row.querySelector('[data-dl]').addEventListener('click',()=>{
        const a=document.createElement('a'); a.href=url; a.download=fname; document.body.appendChild(a); a.click(); a.remove();
        toast('Download avviato');
      });
      if(canOpen){
        row.querySelector('[data-open]').addEventListener('click',()=>{
          window.open(url,'_blank','noopener');
        });
      }
      $list.appendChild(row);
      return url; // per eventuale revoke in futuro
    }

    function toastQueued(msg, ms=5000){
      // tua funzione di coda già esistente; se non ce l’hai, riusa toastCenter con setTimeout a 5s
      toastCenter(msg); // e mantieni durata 5000ms globalmente
    }

    
    
    function notifyNotLocalized(notFound){
      if(!notFound || !notFound.length) return;
      const shown = notFound.slice(0,6).join(' · ');
      const suffix = notFound.length>6 ? `… (tot: ${notFound.length})` : '';
      toastQueued(`Non localizzati: ${shown}${suffix}`, 5000);
    }
  
    document.getElementById('btnGenMeteo').addEventListener('click', async()=>{
      try{
        clearUI();
        const lines = $in.value.split('\n').map(s=>s.trim()).filter(Boolean);
        if(!lines.length){ toastCenter('Inserisci un link o una lista'); return; }
  
        // Parsing tokens
        const tokens = await tokensFromInput(lines);
  
        // Geocode -> punti (fmt6s)
        const {ordered, skipped} = await geocodeList(tokens);
        if(ordered.length<2){ toastCenter('Troppi punti non geocodificati'); return; }
        //if(skipped.length){ toastCenter(`Saltati ${skipped.length} punto/i non geocodificati`); }
        if(skipped.length){ notifyNotLocalized(skipped); }
  
        // Label località (no coordinate nei file)
        const labels=[];
        for(let i=0;i<ordered.length;i++){
          $out.querySelector('.note').textContent = `Reverse ${i+1}/${ordered.length}...`;
          labels.push(await reverseShortLocal(ordered[i].lat, ordered[i].lon));
        }
  
        // Distanze/tempi via OSRM
        $out.querySelector('.note').textContent = 'Calcolo distanze e tempi...';
        const {legs, totals} = await buildRouteLegs(ordered);
  
        // Weather per ogni località
        const wxRows = [];
        const wxDayLabelsRef = null;
        let dayLabels = null;
        for(let i=0;i<ordered.length;i++){
          $out.querySelector('.note').textContent = `Meteo ${i+1}/${ordered.length}...`;
          const w = await fetchWeather(ordered[i].lat, ordered[i].lon);
          if(!w || !w.hourly || !w.daily){ throw new Error('Meteo non disponibile'); }
          const g = build7x4(w);
          if(!dayLabels) dayLabels = g.dayLabels;
          wxRows.push({name: labels[i], parts: g.grid.map((x)=>x), minmax: g.dMin.map((mn,di)=>({min:g.dMin[di], max:g.dMax[di]}))});
        }
  
        // Titoli
        const startName = fileNameSafe(labels[0]);
        const endName   = fileNameSafe(labels[labels.length-1]);
        const title = `Meteo da: ${labels[0]} a: ${labels[labels.length-1]}`;
        const stamp = nowStamp();
  
        // HTML METEO
        const htmlWeek = htmlMeteoWeek(title, wxRows, dayLabels);
        const htmlBlobWeek = new Blob([htmlWeek], {type:'text/html;charset=utf-8'});
        const htmlDay = htmlMeteoDay(title, wxRows, dayLabels);
        const htmlBlobDay = new Blob([htmlDay], {type:'text/html;charset=utf-8'});
        
        function buildInfoPercorsoCSV(rows){
          const esc = s => `"${String(s).replace(/"/g,'""')}"`;
          const km = k => formatKmIT(k).replace(' km',''); // solo numero con virgola
          //const km = k => formatKmIT(k);
          const tm = (h,m) => `${h} h ${m} m`;
        
          const out = [];
          out.push('Punto;Localita;Totale Km;Totale Tempo;Parziale Km;Parziale Tempo');
          for(const r of rows){
            out.push([
              r.idx,
              esc(r.name),
              km(r.totKm),
              tm(r.totH,r.totM),
              km(r.parzKm),
              tm(r.parzH,r.parzM)
            ].join(';'));
          }
          return out.join('\n');
        }

        // === helpers per durata (se non già presenti) ===
        function secToHM(sec){
          sec = Math.round(sec||0);
          const h = Math.floor(sec/3600);
          const m = Math.floor((sec%3600)/60);
          return {h,m};
        }
        
        // === costruzione righe per TXT/CSV con lo stile PS ===
        // labels: nomi località (senza coordinate)
        // legs: [{dist, dur}] dist in metri, dur in secondi, per i salti i->i+1
        // totals: {dist, dur} dist in metri, dur in secondi (totali)
        const rows = [];
        let cumD = 0; // metri
        let cumT = 0; // secondi
        
        for (let i=0; i<labels.length; i++){
          let dPar = 0, tPar = 0;
          if (i>0 && legs[i-1]) {
            dPar = +legs[i-1].dist || 0;
            tPar = +legs[i-1].dur  || 0;
          }
          cumD += dPar;
          cumT += tPar;
        
          const {h: totH,  m: totM}  = secToHM(cumT);
          const {h: parzH, m: parzM} = secToHM(tPar);
        
          rows.push({
            idx: i+1,
            name: labels[i],
            totKm: cumD/1000,   // in km (numero)
            totH, totM,         // ore/min
            parzKm: dPar/1000,  // in km (numero)
            parzH, parzM
          });
        }
        
        const titolo = { da: labels[0], a: labels[labels.length-1] };
        
        // Usa i builder “PS-style”
        const txtStr = buildInfoPercorsoTXT(rows, titolo) + '\n';
        const csvStr = buildInfoPercorsoCSV(rows) + '\n';
        
        // Blob con LF (Unix) e UTF-8
        const txtBlob = new Blob([txtStr.replace(/\r?\n/g,'\n')], { type:'text/plain;charset=utf-8' });
        const csvBlob = new Blob([csvStr.replace(/\r?\n/g,'\n')], { type:'text/csv;charset=utf-8' });

  
        // File names (PS-style)
        const base = `${startName.toLowerCase().replace(/\s+/g,'_')}_${endName.toLowerCase().replace(/\s+/g,'_')}_${stamp}`;
        const fHTMLWeek = `meteo_percorso_week_${base}.html`;
        const fHTMLDay = `meteo_percorso_day_${base}.html`;
        const fTXT  = `info_percorso_${base}.txt`;
        const fCSV  = `info_percorso_${base}.csv`;
  
        $out.querySelector('.note').textContent = `Creati 4 file · aggiornato alle ${timeHHMMSS()}`;
        addFileRow('Meteo (visione settimanale)', htmlBlobWeek, fHTMLWeek, true);
        addFileRow('Meteo (visione giorno x giorno)', htmlBlobDay, fHTMLDay, true);
        addFileRow('Info Percorso TXT', txtBlob, fTXT, true);
        addFileRow('Info Percorso CSV', csvBlob, fCSV, false);
        toastCenter('Meteo + Info percorso pronti');
      }catch(e){
        console.error(e);
        toastCenter('Errore: '+(e&&e.message?e.message:String(e)));
      }
    });
  })();
  </script>
</body>
</html>
