<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GPX2MAPS Web-APP</title>
  <meta name="description" content="Software per gestire al 100% itinerati con Google Maps in modalità navigabile" />
  <style>
    :root{
      --accent:#e11d48; --fg:#0f172a; --muted:#475569; --bg:#f8fafc;
      --card:#fff; --border:#e2e8f0; --btn:#0ea5e9; --btn2:#22c55e; --btnDanger:#ef4444;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;color:var(--fg);background:var(--bg)}
    header{padding:20px 16px 8px;background:var(--card);border-bottom:1px solid var(--border)}
    .hero{max-width:1100px;margin:0 auto;display:flex;align-items:center;gap:16px}
    .hero img{width:44px;height:44px;border-radius:10px}
    .title{font-weight:800;font-size:24px;line-height:1.1}
    .subtitle{color:var(--accent);font-weight:700}
    .cta{margin:12px 0 0;display:flex;justify-content:center;gap:10px;flex-wrap:wrap}
    .btn{appearance:none;border:1px solid transparent;background:var(--btn);color:#fff;padding:10px 14px;border-radius:999px;cursor:pointer;font-weight:700}
    .btn.secondary{background:var(--btn2)} .btn.ghost{background:#fff;color:var(--fg);border-color:var(--border)} .btn.small{padding:6px 10px;font-weight:600} .btn.danger{background:var(--btnDanger)}
    .container{max-width:1100px;margin:0 auto;padding:16px}
    .note{margin:14px 0 6px;color:var(--muted);font-size:14px}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;border-bottom:1px solid var(--border);margin-top:12px}
    .tab{padding:10px 12px;cursor:pointer;border:1px solid var(--border);border-bottom:none;border-radius:10px 10px 0 0;background:#f1f5f9;font-weight:700}
    .tab.active{background:#fff;color:#0ea5e9}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
    .card .hd{padding:14px 16px;border-bottom:1px solid var(--border);font-weight:800}
    .card .bd{padding:16px}
    .grid{display:grid;grid-template-columns:1fr;gap:16px}
    @media(min-width:900px){.grid-2{grid-template-columns:1.4fr 1fr}}
    textarea{width:100%;min-height:180px;resize:vertical;padding:12px;border-radius:10px;border:1px solid var(--border);font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;word-break:break-all}
    dialog{border:none;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.2);width:min(560px,92vw)} dialog::backdrop{background:rgba(0,0,0,.35)}
    #toastsCenter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;z-index:60}
    .toast.center{padding:12px 16px;font-size:15px;background:rgba(17,24,39,.95);color:#fff;border-radius:10px;box-shadow:0 6px 16px rgba(0,0,0,.28);animation:fadePop .28s ease-out}
    @keyframes fadePop{from{opacity:0;transform:translateY(6px) scale(.98)}to{opacity:1;transform:translateY(0) scale(1)}}
    .out-item+.out-item{margin-top:8px}
    footer{margin:36px auto 24px;max-width:1100px;color:var(--muted);font-size:13px;padding:0 16px}
  </style>
</head>
<body>
  <header>
    <div class="hero">
      <img src="/gpx2maps_icon_1024.png" alt="Logo GPX2MAPS" />
      <div>
        <div class="title">GPX2MAPS Web-APP</div>
        <div class="subtitle">by Pieghello</div>
      </div>
    </div>
    <div class="cta">
      <a id="donateBtn" class="btn" href="#" target="_blank" rel="noopener">Dona</a>
      <a id="amazonBtn" class="btn secondary" href="#" target="_blank" rel="noopener">Offerte e Coupon Amazon</a>
    </div>
  </header>

  <div class="container">
    <div class="note">Software per gestire al 100% itinerati con Google Maps in modalità navigabile</div>

    <div class="tabs" role="tablist">
      <button class="tab active" role="tab" aria-selected="true"  data-tab="merge">Fusione Link</button>
      <button class="tab"         role="tab" aria-selected="false" data-tab="maps2gpx">2) Google Maps → GPX</button>
      <button class="tab"         role="tab" aria-selected="false" data-tab="gpx2maps">3) GPX → Google Maps</button>
      <button class="tab"         role="tab" aria-selected="false" data-tab="sanitize">4) Sanitizza GPX</button>
      <button class="tab"         role="tab" aria-selected="false" data-tab="meteo">5) Meteo + Info percorso</button>
    </div>

    <!-- TAB 1 -->
    <section id="tab-merge" class="card">
      <div class="hd">Fusione, ottimizzazione e split dei link Google Maps</div>
      <div class="bd grid grid-2">
        <p class="note" style="grid-column:1/-1;">
          Il limite su Google Maps è di 10 punti, con questo strumento possiamo arrivare a 25 in modalità navigabile che è il vero limite nascosto di Google. Se si dovessero superare i 25 punti, verrebbe proposto o di ottimizzare a 25, mantenendo fissi il primo e l'ultimo punto, oppure si possono generare tanti link da 25 punti fino al completamento dell'intero itinerario
        </p>
        <div>
          <label for="linksInput" style="font-weight:800;">Incolla i link (uno per riga)</label>
          <textarea id="linksInput" placeholder="Incolla link tipo https://www.google.*/maps/dir/... (uno per riga). Accetta anche maps.app.goo.gl"></textarea>
          <div class="row" style="margin-top:12px;">
            <button id="btnMerge" class="btn">Analizza e Unisci</button>
            <button id="btnClear" class="btn ghost">Pulisci</button>
          </div>
        </div>
        <div>
          <div class="out card">
            <div class="hd">Risultati</div>
            <div class="bd">
              <div id="stats" class="note">Nessun risultato ancora.</div>
              <div id="output"></div>
              <div class="row" style="margin-top:10px;">
                <button id="btnDownloadAll" class="btn small" style="display:none;">Scarica .txt</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- TAB 2 -->
    <section id="tab-maps2gpx" class="card" hidden>
      <div class="hd">2) Google Maps → GPX</div>
      <div class="bd grid grid-2">
        <div>
          <label for="maps2gpxInput" style="font-weight:800;">Incolla un link Google Maps (itinerario) o una lista di indirizzi/coordinate</label>
          <textarea id="maps2gpxInput" placeholder="Esempi:
- https://www.google.com/maps/dir/Punto+A/Punto+B/...
- Indirizzi o lat,lon (uno per riga)
- Puoi incollare link con // iniziale: qui viene ignorato (come nello script)"></textarea>
          <div class="row" style="margin-top:12px;">
            <button id="btnGenGPX" class="btn">Genera GPX</button>
            <button id="btnClear2" class="btn ghost">Pulisci</button>
          </div>
        </div>
        <div>
          <div class="out card">
            <div class="hd">Risultati</div>
            <div class="bd">
              <div id="stats2" class="note">Nessun file generato.</div>
              <details id="previewWrapRte" style="margin-top:8px;" hidden>
                <summary>Anteprima GPX Rotta (WPT + RTE)</summary>
                <pre id="gpxPreviewRte" class="mono" style="max-height:220px;overflow:auto;white-space:pre;background:#f8fafc;border:1px solid var(--border);padding:10px;border-radius:10px;"></pre>
              </details>
              <details id="previewWrapTrk" style="margin-top:8px;" hidden>
                <summary>Anteprima GPX Traccia (WPT + TRK)</summary>
                <pre id="gpxPreviewTrk" class="mono" style="max-height:220px;overflow:auto;white-space:pre;background:#f8fafc;border:1px solid var(--border);padding:10px;border-radius:10px;"></pre>
              </details>
              <div class="row" id="dlRow" style="margin-top:10px;display:none;">
                <button id="btnDownloadRTE" class="btn small">Scarica GPX Rotta</button>
                <button id="btnDownloadTRK" class="btn small">Scarica GPX Traccia</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Placeholder altri tab -->
    <section id="tab-gpx2maps" class="card" hidden>
      <div class="hd">3) GPX → Google Maps</div>
      <div class="bd grid grid-2">
        <div>
          <label style="font-weight:800;">Carica un file GPX (o incolla il testo)</label>
          <div class="row" style="margin-top:8px;">
            <input id="gpxFile" type="file" accept=".gpx,application/gpx+xml,text/xml" />
            <button id="btnParseGPX" class="btn">Analizza GPX</button>
            <button id="btnClear3" class="btn ghost">Pulisci</button>
          </div>
          <textarea id="gpxText" placeholder="(Opzionale) Incolla qui il contenuto GPX se non usi il file"></textarea>
          <div id="whichButtons" class="row" style="margin-top:10px; display:none;">
            <button id="btnMakeWPT" class="btn small">Crea link da WPT</button>
            <button id="btnMakeRTE" class="btn small">Crea link da RTE</button>
            <button id="btnMakeTRK" class="btn small">Crea link da TRK</button>
          </div>
        </div>
        <div>
          <div class="out card">
            <div class="hd">Risultati</div>
            <div class="bd">
              <div id="stats3" class="note">Nessun GPX analizzato.</div>
              <div id="output3"></div>
              <div class="row" style="margin-top:10px;">
                <button id="btnDownloadAll3" class="btn small" style="display:none;">Scarica .txt</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <!-- TAB 4 -->
    <section id="tab-sanitize" class="card" hidden>
      <div class="hd">4) Sanitizza GPX</div>
      <div class="bd grid grid-2">
        <div>
          <label for="sanitizeInput" style="font-weight:800;">Incolla il GPX (oppure apri un file)</label>
          <textarea id="sanitizeInput" placeholder="Incolla qui il contenuto del file .gpx"></textarea>
          <div class="row" style="margin-top:12px;">
            <input id="sanitizeFile" type="file" accept=".gpx,application/gpx+xml" />
            <button id="btnSanitize" class="btn">Sanifica GPX</button>
            <button id="btnClear4" class="btn ghost">Pulisci</button>
          </div>
        </div>
        <div>
          <div class="out card">
            <div class="hd">Risultati</div>
            <div class="bd">
              <div id="stats4" class="note">Nessun file sanificato.</div>
              <details id="previewWrapSan" style="margin-top:8px;" hidden>
                <summary>Anteprima GPX sanificato</summary>
                <pre id="gpxPreviewSan" class="mono" style="max-height:220px;overflow:auto;white-space:pre;background:#f8fafc;border:1px solid var(--border);padding:10px;border-radius:10px;"></pre>
              </details>
              <div class="row" id="dlRow4" style="margin-top:10px;display:none;">
                <button id="btnDownloadSan" class="btn small">Scarica GPX sanificato</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <section id="tab-meteo" class="card" hidden>
      <div class="hd">5) Meteo + Info percorso</div>
      <div class="bd grid grid-2">
        <div>
          <label for="meteoInput" style="font-weight:800;">Incolla 1 link Google Maps <em>(/dir/…)</em> oppure località/coordinate (una per riga)</label>
          <textarea id="meteoInput" placeholder="Esempi:
    - https://maps.app.goo.gl/...
    - https://www.google.com/maps/dir/Como/.../Bellagio/...
    - Località o lat,lon (una per riga)"></textarea>
          <div class="row" style="margin-top:12px;">
            <button id="btnGenMeteo" class="btn">Genera Meteo (HTML, TXT, CSV)</button>
            <button id="btnClear5" class="btn ghost">Pulisci</button>
          </div>
          <p id="stats5" class="note" style="margin-top:8px;">Nessun file generato.</p>
        </div>
    
        <div>
          <div class="out card">
            <div class="hd">File generati</div>
            <div class="bd" id="files5">
              <div class="note">Niente ancora.</div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <footer>
    L'applicazione è stata realizzata a scopo gratuito per la comunità. Se si vuole fare un'opera di gentilezza nei confronti dello sviluppatore che ci ha perso del tempo per realizzarla, si prega di effettuare una donazione con il pulsante ‘Dona’ in alto. Approfitta anche del link diretto alla pagina nascosta di Amazon con tutte le offerte e coupon, che è accessibile con il pulsante che si trova sempre in alto.
  </footer>

  <!-- Modals -->
  <dialog id="confirmDialog">
    <form method="dialog" style="padding:18px 18px 8px;">
      <h3 style="margin:0 0 6px;font-weight:900;">Confermi l'operazione?</h3>
      <p id="confirmText" style="margin:0 0 14px;color:var(--muted);"></p>
      <div class="row" style="justify-content:flex-end;">
        <button class="btn ghost" value="cancel">Annulla</button>
        <button class="btn" value="ok">Conferma</button>
      </div>
    </form>
  </dialog>

  <dialog id="strategyDialog">
    <form method="dialog" style="padding:18px 18px 8px;">
      <h3 style="margin:0 0 6px;font-weight:900;">Troppi punti per un singolo link</h3>
      <p style="margin:0 0 10px;color:var(--muted);">Hai superato il limite di 25 (incluso il primo punto con la tua posizione GPS). Scegli una strategia:</p>
      <div class="row" style="flex-direction:column;align-items:stretch;gap:10px;">
        <button id="btnStrategyOptimize" class="btn" value="opt">1) Ottimizza a 25 (mantieni testa/coda, campiona gli intermedi)</button>
        <button id="btnStrategySplit" class="btn secondary" value="split">2) Dividi in più link (max 25 punti; solo il primo ha “//”)</button>
      </div>
      <div class="row" style="justify-content:flex-end;margin-top:10px;">
        <button class="btn ghost" value="cancel">Chiudi</button>
      </div>
    </form>
  </dialog>

  <div id="toastsCenter" aria-live="polite" aria-atomic="true"></div>

  <script>
    /* === CONFIG senza object literal (no caratteri invisibili) === */
    const CONFIG = {};
    CONFIG.workerBase = "https://gpx2maps-worker.stefano-vitro.workers.dev";
    CONFIG.paypalDonateUrl = "https://www.paypal.com/donate?business=stefano.vitro%40gmail.com&no_recurring=0&item_name=Supporto+sviluppo+GPX2MAPS&currency_code=EUR";
    CONFIG.amazonAffiliateUrl = "https://amzn.to/41o2XjA";

    document.getElementById('donateBtn').href=CONFIG.paypalDonateUrl;
    document.getElementById('amazonBtn').href=CONFIG.amazonAffiliateUrl;

    /* Tabs */
    const tabs=[...document.querySelectorAll('.tab')];
    tabs.forEach(btn=>btn.addEventListener('click',()=>{
      tabs.forEach(b=>{b.classList.remove('active');b.setAttribute('aria-selected','false')});
      btn.classList.add('active');btn.setAttribute('aria-selected','true');
      const id=btn.dataset.tab;
      ['merge','maps2gpx','gpx2maps','sanitize','meteo'].forEach(k=>{
        const s=document.getElementById(`tab-${k}`);
        if(s) s.hidden = k!==id && !(k==='merge'&&id===undefined);
      });
    }));

    /* Toast center in coda (5s, niente overwrite) */
    const _toastQ = [];
    let _toastShowing = false;
    
    function _toastShowNext(){
      if(_toastShowing || !_toastQ.length) return;
      _toastShowing = true;
      const msg = _toastQ.shift();
      const box = document.getElementById('toastsCenter');
      const t = document.createElement('div');
      t.className = 'toast center';
      t.textContent = msg;
      box.appendChild(t);
      setTimeout(()=>{
        if(t.parentNode) t.parentNode.removeChild(t);
        _toastShowing = false;
        _toastShowNext();
      }, 5000);
    }
    function toastCenter(msg){ _toastQ.push(msg); _toastShowNext(); }
    function toast(msg){ toastCenter(msg); }
    
    function _pumpToast(){
      if (toastBusy || toastQueue.length===0) return;
      toastBusy = true;
    
      const box = document.getElementById('toastsCenter');
      box.innerHTML = ''; // mostro un solo toast per volta
      const t = document.createElement('div');
      t.className = 'toast center';
      t.textContent = toastQueue.shift();
      box.appendChild(t);
    
      setTimeout(()=>{
        if (t.parentNode) t.parentNode.removeChild(t);
        toastBusy = false;
        _pumpToast(); // mostra il prossimo in coda
      }, TOAST_MS);
    }
    
    async function confirmAction(text){
      const dlg=document.getElementById('confirmDialog');
      document.getElementById('confirmText').textContent=text||'';
      dlg.showModal();
      const v=await new Promise(r=>dlg.addEventListener('close',()=>r(dlg.returnValue),{once:true}));
      return v==='ok';
    }
    async function getJSON(u){
      const r=await fetch(u,{headers:{'Accept':'application/json'}});
      if(!r.ok) throw new Error('HTTP '+r.status);
      return r.json();
    }

    /* Helpers */
    // === Helpers per matching "strict" token vs display_name Nominatim
    /* POI hard-coded (eccezioni controllate) */
    const POI_FIX = [
      {
        label: 'Orrido di Bracca',
        lat: '45.846870', lon: '9.731200',
        match: (raw) => {
          const n = normText(raw);
          // copre “Orrido di Bracca”, “Orrido del Bracca”, varianti con punteggiatura o plus
          return n.includes('orrido di bracca') || n.includes('orrido del bracca') || n.includes('orrido bracca');
        }
      },
      {
        label: 'Passo del Grimsel',
        lat: '46.561400', lon: '8.337580',
        match: (raw) => {
          const n = normText(raw);
          // copre "Passo del Grimsel", "Grimselpass", ecc.
          return n.includes('grimsel');
        }
      },
    ];
    // --- normalizzazioni/sinonimi per match "leggero" ---
    function normStr(s){
      return String(s).toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
        .replace(/[.,;:()'’"“”]/g,' ')
        .replace(/\s+/g,' ').trim();
    }
    // gruppo di equivalenze: la prima parola è il "core"
    const SYN_EQUIV = [
      ['grimsel','grimselpass','passodelgrimsel','grimsel pass',
       'grimselpasshohe','grimselpasshöhe','grimsel-pass','grimsel-passhohe','grimsel-passhöhe'],
      ['nufenen','novena','nufenenpass','passonovena','passo della novena'],
      ['sempione','simplon','simplonpass','passodelsempione','passo del sempione'],
      ['goms','obergoms'],
      ['svizzera','switzerland'],
      ['italia','italy']
    ];
    function applySynonyms(s){
      let out = ' ' + normStr(s) + ' ';
      for(const group of SYN_EQUIV){
        const core = group[0];
        for(const alias of group){
          const re = new RegExp(`(?<=\\s)${alias.replace(/[-/\\^$*+?.()|[\]{}]/g,'\\$&')}(?=\\s)`,'g');
          out = out.replace(re, ` ${core} `);
        }
      }
      return out.trim();
    }
    // parole generiche da ignorare nei keyword
    const GENERIC_WORDS = new Set([
      'passo','pass','colle','forcella','galleria','tunnel','orrido',
      'provincia','cantone','distretto','circolo','comune'
    ]);    
    function keywordsForMatch(token){
      const words = applySynonyms(token).split(' ');
      const out = [];
      for(const w of words){
        if(!w) continue;
        if(GENERIC_WORDS.has(w)) continue;
        if(/^\d+$/.test(w)) continue;
        if(w.length<=2) continue;
        out.push(w);
      }
      return [...new Set(out)];
    }
    const IT_STOP = new Set([
      'di','del','della','delle','dei','degli','la','il','lo','i','gli','le','e','ed',
      'in','da','su','al','ai','agli','alla','alle','dal','sul','per','con',
      // paesi/province/sigle
      'italia','svizzera','switzerland','italy','provincia','province',
      'mi','co','va','lc','bg','ge','no','vb','vs'
    ]);
    function keywordsFromToken(s){
      const arr = applySynonyms(s).split(' ');
      return arr.filter(w => {
        if(!w) return false;
        if(IT_STOP.has(w)) return false;
        if(/^[0-9]+$/.test(w)) return false;     // ZIP/civici
        if(w.length <= 3) return false;          // sigle molto corte
        return true;
      });
    }
    // match "severo ma giusto", con soglia morbida per passi/colle
    function nameMatchesToken(token, display){
      const hayNorm = ' ' + applySynonyms(display) + ' ';
      const tokNorm = applySynonyms(token);
      const kw = keywordsForMatch(tokNorm);
      if(!kw.length) return true;
    
      // caso "passo/colle": basta che compaia il nome del passo
      const PASS_KEYS = ['grimsel','nufenen','novena','sempione','simplon'];
      const isPass = /\b(pass|passo|colle)\b/i.test(tokNorm);
      if(isPass){
        for(const k of PASS_KEYS){
          if(tokNorm.includes(k) && hayNorm.includes(' ' + k + ' ')) return true;
        }
      }
    
      let hit=0;
      for(const w of kw){
        if(hayNorm.includes(' ' + w + ' ') || hayNorm.includes(w)) hit++;
      }
      const threshold = isPass ? 0.45 : 0.60;
      return (hit/kw.length) >= threshold;
    }
    // pulizia *prima* del geocoding (togli CAP/codici, “Provincia di …”)
    function cleanForGeocode(t){
      let s = decodeTok(t);
      s = s.replace(/\bch[-\s]?\d{4,5}\b/gi,''); // CH-3999
      s = s.replace(/\b\d{4,5}\b/g,'');         // 3999, 3907, 20100...
      s = s.replace(/,\s*(?:MI|CO|VA|LC|BG|GE|NO|VB|VS|TI|GR|UR|BE|ZH|ZG|SG|VD|JU|FR|BS|BL|AG|SO|AR|AI|GE|LU|NE|OW|NW|SH|SZ|TG)\b/gi,'');
      s = s.replace(/\bprovincia\s+di\s+[a-zà-ù]+/gi,'');
      s = s.replace(/\s*,\s*,+/g,',');          // comprime virgole doppie
      s = s.replace(/^[,\s]+|[,\s]+$/g,'');     // toglie virgole/spazi ai bordi
      s = s.replace(/\s{2,}/g,' ').trim();
      if(s.endsWith(',')) s = s.slice(0,-1).trim();
      return s;
    }
    function looksLocalityClass(g){
      const c = String(g && g.class || '');
      return /^(place|boundary|highway|natural|mountain_pass|waterway|aeroway|railway|man_made)$/.test(c);
    }
    function tokenMentionsCountry(t){
      return /\b(italia|svizzera|francia|france|germania|austria|slovenia)\b/i.test(String(t));
    }
    // === Riconoscimento "località" vs "POI/commerciale" + match stretto per POI ===
    const POI_KEYWORDS = [
      'autogrill','hotel','ristorante','pizzeria','birroteca','trattoria','osteria','bar',
      'mcdonald','burger king','ikea','decathlon','outlet','supermercato','esselunga',
      'carrefour','coop','lidl','iper','ipercoop','conad','eni','q8','tamoil','ip',
      'stazione di servizio','area di servizio','area servizio','services','service'
    ];
    const STREET_WORDS_RE = /\b(via|viale|piazza|piazzale|corso|largo|strada|autostrada|uscita|svincolo|tangenziale)\b/i;
    const ROAD_CODE_RE    = /\b(a\d+|ss\d+|sp\d+|sr\d+)\b/i;
    
    function _norm(s){
      return String(s||'').toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g,''); // senza accenti
    }
    function hasPOIKeyword(token){
      const s=_norm(token);
      return POI_KEYWORDS.some(k=>s.includes(k));
    }
    function coreWordsForPOI(token){
      const s=_norm(token).replace(/[^\p{L}\p{N}\s]/gu,' ');
      const stop = new Set(['italia','italy','svizzera','switzerland','provincia','comune','citta','city','town','village','hamlet','localita',
        'di','del','della','delle','degli','dei','da','dal','dallo','dalla','allo','alla','al','ai','agli','alle','lo','la','le','il','in','su'
      ]);
      return s.split(/\s+/).filter(w => w && w.length>=3 && !stop.has(w) && !/^\d{5}$/.test(w));
    }
    function isLocalityToken(token){
      const s=_norm(token);
      if (STREET_WORDS_RE.test(s)) return false;
      if (ROAD_CODE_RE.test(s))   return false;
      if (hasPOIKeyword(token))   return false;
      // indirizzo preciso "Via ..., 11"
      if (/, *\d+\b/.test(token) && /\b(via|viale|piazza|corso|largo|piazzale)\b/i.test(token)) return false;
      return true;
    }
    function poiAccept(token, geocoded){
      if(!geocoded) return false;
      const disp=_norm(geocoded.display_name||'');
      const cls=(geocoded.class||geocoded.category||'').toLowerCase();
      const type=(geocoded.type||'').toLowerCase();
    
      const words = coreWordsForPOI(token);
      let hits=0; for(const w of words){ if(disp.includes(w)) hits++; }
    
      // se il token ha un brand esplicito, deve comparire nel risultato
      const tokenHasBrand = hasPOIKeyword(token);
      const brandOk = !tokenHasBrand || POI_KEYWORDS.some(k=>disp.includes(k));
    
      // classi accettabili per POI; per highway accettiamo solo aree/servizi autostradali
      const classOk = /^(amenity|tourism|shop|leisure|man_made|highway|place)$/.test(cls);
      const highwayOk = (cls!=='highway') || /^(services|rest_area|motorway_junction|service|fuel)$/.test(type);
    
      // Match stretto: almeno 2 parole significative, e se c'è brand dev'essere presente
      return classOk && highwayOk && brandOk && (hits>=2);
    }
    
    // === Indizi per validare i fallback Nominatim ===
    function _norm(s){
      return String(s||'').toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g,''); // togli accenti
    }
    function hasCountryWord(s){
      return /\b(italia|italy|svizzera|switzerland)\b/i.test(s);
    }
    function hintsFromToken(token){
      const cap = (token.match(/\b\d{5}\b/g)||[])[0] || null;       // CAP italiano
      const parts = token.split(',').map(x=>x.trim()).filter(Boolean);
      const tail = parts.slice(-2).join(' ');                       // ultime 1-2 parti
      const tailKw = _norm(tail).split(/\s+/).filter(w=>w.length>=4 && /^[a-z]/.test(w));
      return { cap, tailKw };
    }
    function acceptByHints(originalToken, geocoded){
      if(!geocoded) return false;
      const disp = _norm(geocoded.display_name||'');
      const {cap, tailKw} = hintsFromToken(originalToken);
    
      // 1) CAP presente nel display_name => forte indicazione
      if(cap && disp.includes(cap)) return true;
    
      // 2) almeno 2 keyword significative dalle ultime parti compaiono nel display_name
      let hits = 0;
      for(const kw of tailKw){ if(disp.includes(kw)) hits++; }
      return hits >= 2;
    }
    function buildFallbackQueries(token){
      const out = [];
      const needCountry = !hasCountryWord(token);
      const add = q => { if(q && q!==token && !out.includes(q)) out.push(q); };
    
      const stripProvincia = s => s.replace(/\bprovincia di\b\s*/i,'').replace(/\bprov\.\s*/i,'');
    
      const parts = token.split(',').map(s=>s.trim()).filter(Boolean);
      if(parts.length>=2) add(stripProvincia(parts.slice(-2).join(', ')) + (needCountry? ', Italia' : ''));
      if(parts.length>=1) add(stripProvincia(parts.slice(-1)[0])          + (needCountry? ', Italia' : ''));
      add(stripProvincia(token) + (needCountry? ', Italia' : ''));
    
      return out;
    }
    
    // --- helper: pulizia minima indirizzi IT quando il primo tentativo fallisce ---
    function cleanAddressTokenForGeocode(raw){
      let s = decodeTok(raw).replace(/\s+/g,' ').trim();
    
      // 1) se il primo pezzo prima della virgola sembra un brand (niente numeri e non "via/viale/..."), lo scarto
      const parts = s.split(',');
      if (parts.length >= 2) {
        const first = parts[0].trim().toLowerCase();
        const looksLikeBrand = !/\d/.test(first) &&
          !/^(via|viale|v\.|viale|piazza|p\.za|corso|largo|strada|ss|sp|sr|autostrada|a\d+)/i.test(first);
        if (looksLikeBrand) s = parts.slice(1).join(',').trim();
      }
    
      // 2) tolgo eventuale sigla provincia finale (", MI" oppure " MI")
      s = s.replace(/,\s*[A-Z]{2}\b$/,'').replace(/\s+[A-Z]{2}\b$/,'');
    
      // 3) normalizzo un possibile inizio tipo "A1" -> "Autostrada A1" (aiuta Nominatim)
      s = s.replace(/^A(\d+)\b/i,'Autostrada A$1');
    
      return s.replace(/\s+/g,' ').trim();
    }
    // Normalizza query "rognose" (Provincia di..., CAP+sigla, ecc.)
    function normalizeQuery(q){
      let s = String(q);
    
      // "Provincia di Bergamo" -> "Bergamo"
      s = s.replace(/\bProvincia di\s+([^,]+)/gi, '$1');
    
      // ", 24121-24129" o ", 22100 CO" o ", 22100"
      s = s.replace(/,\s*\d{5}(?:-\d{5})?\s*[A-Z]{0,2}\b/gi, '');
    
      // ", CO" (solo sigla provincia)
      s = s.replace(/,\s*[A-Z]{2}\b/g, '');
    
      // spazi multipli / virgole sporche
      s = s.replace(/\s{2,}/g, ' ').replace(/\s*,\s*/g, ', ').trim();
    
      return s;
    }
    function stripAtTail(s){ return s.replace(/\/@.*$/,'').replace(/\/data=.*$/,''); }
    function decodeTok(p){ try{return decodeURIComponent(p).replace(/\+/g,' ').trim()}catch{return p.replace(/\+/g,' ').trim()} }
    function xmlEscape(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&apos;'); }
    function fileNameSafe(s){ return (s||'').replace(/[\\\/:*?"<>|]/g,'').replace(/\s+/g,' ').trim(); }
    function nowStamp(){ const d=new Date(),p=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}${p(d.getMonth()+1)}${p(d.getDate())}_${p(d.getHours())}${p(d.getMinutes())}${p(d.getSeconds())}`; }
    function timeHHMMSS(){ const d=new Date(),p=n=>String(n).padStart(2,'0'); return `${p(d.getHours())}:${p(d.getMinutes())}:${p(d.getSeconds())}`; }
    function joinLF(a){ return a.join('\n'); }
    // Normalizza un testo: toglie accenti, punteggiatura, lowercase e comprime gli spazi
    function normText(s){
      return String(s)
        .normalize('NFD').replace(/[\u0300-\u036f]/g,'') // rimuovi diacritici
        .toLowerCase()
        .replace(/[^a-z0-9]+/g,' ') // tieni solo lettere/numeri
        .trim();
    }
    // HALF-EVEN (banker's) a 6 decimali – come PS
    function roundHalfEvenStr(x, d=6){
      let s=(typeof x==='number')?x.toString():String(x).trim();
      if(!isFinite(+s)) return (0).toFixed(d);
      if(/[eE]/.test(s)) s=(+s).toFixed(d+10);
      let sign=''; if(s[0]==='-'||s[0]==='+'){ if(s[0]==='-') sign='-'; s=s.slice(1); }
      if(!s.includes('.')) s+='.0';
      let [I,F='']=s.split('.'); I=I.replace(/\D/g,'')||'0'; F=F.replace(/\D/g,'');
      while(F.length<d+1) F+='0';
      const keep=I.length+d, digits=I+F, kept=digits.slice(0,keep)||'0', firstDrop=digits[keep]||'0', restDrop=digits.slice(keep+1);
      let up=false;
      if(firstDrop>'5') up=true;
      else if(firstDrop<'5') up=false;
      else up = /[1-9]/.test(restDrop) ? true : (parseInt(kept[kept.length-1]||'0',10)%2===1);
      let n=BigInt(kept); if(up) n+=1n;
      let rs=n.toString(); while(rs.length<=d) rs='0'+rs;
      const pos=rs.length-d; let out=rs.slice(0,pos)+'.'+rs.slice(pos);
      if(sign==='-' && out!=='0.'+'0'.repeat(d)) out='-'+out;
      return out;
    }
    const fmt6s = x => roundHalfEvenStr(x, 6);

    /* ===== TAB 1: Merge ===== */
    function extractDirSegment(s){
      const m=stripAtTail(s.trim()).match(/^https?:\/\/[^/]*google\.[^/]+\/maps\/dir\/(.+)$/i);
      if(!m) return null;
      return m[1].replace(/^\/+/, '').replace(/\/+$/,''); // rimuovi slash iniziali per evitare /dir///
    }
    async function resolveIfShort(url){
      let u = url;
  
      // 1) segui gli shortlink (maps.app.goo.gl / goo.gl / g.co) via worker /resolve
      try{
        const h=(new URL(url)).host;
        if (/(^|\.)maps\.app\.goo\.gl$/i.test(h) || /(^|\.)goo\.gl$/i.test(h) || /(^|\.)g\.co$/i.test(h)) {
          const {finalUrl} = await getJSON(`${CONFIG.workerBase}/resolve?url=${encodeURIComponent(url)}`);
          if (finalUrl) u = finalUrl;
        }
      }catch{}
  
      // 2) se è un long "strano" di Google con daddr/to: (anche path "/")
      try{
        const U = new URL(u);
        const isGoogle = /(^|\.)google\./i.test(U.host);
        if (isGoogle && (U.pathname === '/' || U.pathname === '/maps')) {
          const raw = U.searchParams.get('daddr');
          if (raw) {
            // decodifica con "+" -> spazio
            const decodePlus = s => decodeURIComponent(String(s).replace(/\+/g,' ')).trim();
            const daddr = decodePlus(raw);
  
            // split su "to:" con o senza spazi
            const dests = daddr.split(/\s+to:/i).map(s=>s.trim()).filter(Boolean);
  
            // costruisci /maps/dir// + destinazioni (ignoriamo saddr: vogliamo "//")
            if (dests.length){
              const segs = ['']; // "//" come primo punto
              segs.push(...dests.map(s => encodeURIComponent(s).replace(/%20/g,'+')));
              return 'https://www.google.com/maps/dir/' + segs.join('/');
            }
          }
        }
      }catch{}
  
      return u;
    }

    function buildGoogleDirURL(parts){ return 'https://www.google.com/maps/dir/'+parts.join('/'); }
    function dedupeAdjacent(a){ const out=[]; let prev=null; for(const x of a){ if(x!==prev) out.push(x); prev=x; } return out; }
    function evenSample(inner,need){ if(need<=0)return[]; if(inner.length<=need)return inner.slice(); const out=[]; for(let i=0;i<need;i++){ const idx=Math.round(i*(inner.length-1)/(need-1)); out.push(inner[idx]); } const res=[]; for(const v of out){ if(res[res.length-1]!==v) res.push(v); } while(res.length>need) res.pop(); return res; }
    function optimizeTo25(all){ if(all.length<=25) return all; const first=all[0], last=all[all.length-1]; const mid=all.slice(1,all.length-1); const sampled=evenSample(mid,23); return [first,...sampled,last].slice(0,25); }
    function splitInBlocks(all){ const MAX=25, blocks=[]; let rest=all.slice(), first=true; while(rest.length){ const chunk=rest.slice(0,MAX); if(!first && chunk[0]==="") chunk.shift(); blocks.push(chunk); rest=rest.slice(MAX); first=false; } return blocks; }

    function renderOutput(urls){
      const out=document.getElementById('output'),stats=document.getElementById('stats'); out.innerHTML='';
      if(!urls.length){ stats.textContent='Nessun risultato.'; document.getElementById('btnDownloadAll').style.display='none'; return; }
      const n=urls.length; stats.textContent=(n===1?'1 link generato':`${n} link generati`)+` · aggiornato alle ${timeHHMMSS()}`;
      urls.forEach(u=>{
        const div=document.createElement('div'); div.className='out-item';
        div.innerHTML=`<div style="display:flex;justify-content:space-between;gap:10px;align-items:center;">
            <div class="mono" style="flex:1 1 auto;">${u}</div>
            <div class="row" style="flex:0 0 auto;">
              <button class="btn small ghost" data-copy>Copia</button>
              <button class="btn small" data-open>Apri</button>
            </div>
          </div>`;
        div.querySelector('[data-copy]').addEventListener('click',async()=>{await navigator.clipboard.writeText(u);toast('URL copiato')});
        div.querySelector('[data-open]').addEventListener('click',async()=>{const ok=await confirmAction('Aprire il link in una nuova scheda?'); if(ok) window.open(u,'_blank','noopener')});
        out.appendChild(div);
      });
      document.getElementById('btnDownloadAll').style.display='';
      toastCenter(`Risultati aggiornati (${n} link)`);
    }

    document.getElementById('btnMerge').addEventListener('click', async ()=>{
      const lines=document.getElementById('linksInput').value.split('\n').map(s=>s.trim()).filter(Boolean);
      if(!lines.length){toastCenter('Inserisci almeno un link');return}

      // Caso 1 link con // => errore (coerente con PS)
      if(lines.length===1 && /https?:\/\/[^/]*google\.[^/]+\/maps\/dir\/\//i.test(lines[0])){
        toastCenter('Errore: almeno due link sono necessari per la fusione.');
        return;
      }

      // Risolvi shortlink
      const resolved=[]; for(const ln of lines){ resolved.push(await resolveIfShort(ln)); }

      // Estrai segmenti /maps/dir/
      const clean=[]; for(const link of resolved){ const seg=extractDirSegment(link); if(seg) clean.push(seg); }
      if(!clean.length){ toastCenter('Nessun link valido "/maps/dir/..." rilevato'); return; }

      // Costruisci punti con blank iniziale
      let all=[""]; for(const seg of clean){ all.push(...seg.split('/')); }

      // Dedup PRIMA del check 25
      all=dedupeAdjacent(all);

      if(all.length<=25){ renderOutput([buildGoogleDirURL(all)]); return; }

      // Strategia
      const dlg=document.getElementById('strategyDialog'); dlg.showModal();
      const strategy=await new Promise(r=>dlg.addEventListener('close',()=>r(dlg.returnValue==='opt'?'optimize':dlg.returnValue==='split'?'split':null),{once:true}));
      if(!strategy){ toastCenter('Operazione annullata'); return; }
      if(strategy==='optimize'){ renderOutput([buildGoogleDirURL(optimizeTo25(all))]); }
      else { const blocks=splitInBlocks(all); renderOutput(blocks.map(b=>buildGoogleDirURL(b))); }
    });

    document.getElementById('btnClear').addEventListener('click',()=>{
      document.getElementById('linksInput').value='';
      document.getElementById('output').innerHTML='';
      document.getElementById('stats').textContent='Pulito.';
      document.getElementById('btnDownloadAll').style.display='none';
    });

    document.getElementById('btnDownloadAll').addEventListener('click',async()=>{
      const items=[...document.querySelectorAll('#output .out-item .mono')].map(x=>x.textContent);
      if(!items.length) return;
      const ok=await confirmAction('Scaricare un file .txt con i link generati?'); if(!ok) return;
      const name=(items.length===1?`merge_1_${nowStamp()}.txt`:`merge_${items.length}_${nowStamp()}.txt`);
      const sep=items.length>1?'\n\n':'\n';
      const bytes=new TextEncoder().encode(items.join(sep));
      const url=URL.createObjectURL(new Blob([bytes],{type:'text/plain'}));
      const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      toast('File scaricato');
    });

    /* ===== TAB 2: Maps -> GPX (RTE & TRK + WPT) ===== */
    function extractDirSegmentKeepLeading(s){
    try{
      const u = new URL(s.trim());
      // prendi esattamente la porzione dopo /maps/dir/ e prima di /@ oppure di ? (se presente)
      const m = u.pathname.match(/\/maps\/dir\/(.+)/i);
      if(!m) return null;
      let seg = m[1];
      // tronca a /@ ... oppure a ?...
      seg = seg.split('/@')[0];
      // se è rimasto un "?" nel path (raro ma succede), tronca anche quello
      seg = seg.split('?')[0];
      // rimuovi eventuali slash finali
      seg = seg.replace(/\/+$/,'');
      return seg;
    }catch{
      // fallback: usa la stringa pura (per sicurezza) con le stesse regole
      const m = s.trim().match(/\/maps\/dir\/(.+)/i);
      if(!m) return null;
      let seg = m[1];
      seg = seg.split('/@')[0];
      seg = seg.split('?')[0];
      seg = seg.replace(/\/+$/,'');
      return seg;
    }
  }

    function isLatLonStr(s){ const m=s.trim().match(/^(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)$/); return m?{lat:m[1],lon:m[2]}:null; }
    async function geocodeTry(q){ try{ const r=await getJSON(`${CONFIG.workerBase}/geocode?q=${encodeURIComponent(q)}`); if(Array.isArray(r)&&r.length) return r[0]; }catch{} return null; }

    // === CLONE PS 1:1 ===
    // - niente fallback ", Italia" o head trimming
    // - lat/lon già arrotondati a 6 decimali qui
    // Geocoding "strict": SOLO da /dir/; accetto il risultato se il nome combacia col token.
    // Unico fallback per località: aggiungo ", Italia" se il token non contiene già il paese.
    // Geocoding "strict": pochi tentativi, sempre verificando il nome trovato
    async function geocodeFreeform(t){
      // coordinate già pronte?
      const ll = isLatLonStr(t);
      if (ll) {
        return { lat: fmt6s(ll.lat), lon: fmt6s(ll.lon), label: `${fmt6s(ll.lat)},${fmt6s(ll.lon)}` };
      }
    
      // --- SALVAGENTE MIRATO: GRIMSEL ---
      // intercetta qualsiasi variazione che contenga "grimsel"
      const tNorm = normStr(t);
      if (/\bgrimsel\b/.test(tNorm)) {
        // coordinate del passo (centro strada) – stabili
        return { lat: fmt6s('46.5614'), lon: fmt6s('8.33758'), label: 'Grimselpass, Svizzera' };
      }
    
      // geocoding "secco"
      const tryOne = async (q) => {
        const g = await geocodeTry(q);
        if (!g) return null;
        const name = g.display_name || '';
        if (nameMatchesToken(t, name)) {
          return { lat: fmt6s(g.lat), lon: fmt6s(g.lon), label: name };
        }
        return null;
      };
    
      // 1) query originale
      let r = await tryOne(t);
      if (r) return r;
    
      // 2) con sinonimi normalizzati
      const qSyn = applySynonyms(tNorm);      // es. "passo del grimsel" -> "grimsel"
      r = await tryOne(qSyn);
      if (r) return r;
    
      // 3) testa la sola "head" (es. "Bellagio" da "Bellagio, CO")
      const head = t.split(',')[0]?.trim();
      if (head && head.length >= 3) {
        r = await tryOne(head);
        if (r) return r;
      }
    
      // NIENTE fallback su POI generici (p.es. "Orrido di Bracca"): li saltiamo di proposito
      return null;
    }

    async function reverseShortLabel(lat,lon){
      try{
        const r=await getJSON(`${CONFIG.workerBase}/reverse?lat=${lat}&lon=${lon}`);
        const a=r&&r.address?r.address:{};
        const city=a.city||a.town||a.village||a.hamlet||'';
        const prov=a.state_district||a.county||'';
        if(city) return prov?`${city} (${prov})`:city;
      }catch{}
      return 'Località';
    }

    function buildGPX_RTE_WPT(points, steps, title){
      const L=[];
      L.push('<?xml version="1.0" encoding="UTF-8"?>');
      L.push('<gpx version="1.1" creator="MAPS2GPX OSRM" xmlns="http://www.topografix.com/GPX/1/1">');
      L.push(`  <metadata><time>${new Date().toISOString()}</time></metadata>`);
      for(let i=0;i<points.length;i++){
        const p=points[i],lat=fmt6s(p.lat),lon=fmt6s(p.lon),name='WP'+String(i+1).padStart(2,'0');
        const desc=p.label?xmlEscape(p.label):`${lat},${lon}`;
        L.push(`  <wpt lat="${lat}" lon="${lon}"><name>${name}</name><desc>${desc}</desc></wpt>`);
      }
      L.push('  <rte><name>'+xmlEscape(title)+'</name>');
      for(const s of steps){
        const lat=fmt6s(s.lat),lon=fmt6s(s.lon),lab=xmlEscape(s.type||'via');
        L.push(`    <rtept lat="${lat}" lon="${lon}"><name>${lab}</name></rtept>`);
      }
      L.push('  </rte>');
      L.push('</gpx>');
      return joinLF(L) + '\n'; // newline finale come PS
    }
    function buildGPX_TRK_WPT(points, trkCoords, title){
      const L=[];
      L.push('<?xml version="1.0" encoding="UTF-8"?>');
      L.push('<gpx version="1.1" creator="MAPS2GPX OSRM" xmlns="http://www.topografix.com/GPX/1/1">');
      L.push(`  <metadata><time>${new Date().toISOString()}</time></metadata>`);
      for(let i=0;i<points.length;i++){
        const p=points[i],lat=fmt6s(p.lat),lon=fmt6s(p.lon),name='WP'+String(i+1).padStart(2,'0');
        const desc=p.label?xmlEscape(p.label):`${lat},${lon}`;
        L.push(`  <wpt lat="${lat}" lon="${lon}"><name>${name}</name><desc>${desc}</desc></wpt>`);
      }
      L.push('  <trk><name>'+xmlEscape(title)+'</name><trkseg>');
      for(const c of trkCoords){
        const lon=fmt6s(String(c[0])),lat=fmt6s(String(c[1]));
        L.push(`    <trkpt lat="${lat}" lon="${lon}" />`);
      }
      L.push('  </trkseg></trk>');
      L.push('</gpx>');
      return joinLF(L) + '\n'; // newline finale come PS
    }

    let gpxRTE=null,gpxTRK=null,nameRTE='',nameTRK='';
    function resetMaps2GPXUI(){
      document.getElementById('stats2').textContent='Nessun file generato.';
      document.getElementById('gpxPreviewRte').textContent='';
      document.getElementById('gpxPreviewTrk').textContent='';
      document.getElementById('previewWrapRte').hidden=true;
      document.getElementById('previewWrapTrk').hidden=true;
      document.getElementById('dlRow').style.display='none';
      gpxRTE=gpxTRK=null; nameRTE=nameTRK='';
    }

    document.getElementById('btnGenGPX').addEventListener('click', async ()=>{
      resetMaps2GPXUI();
      const raw=document.getElementById('maps2gpxInput').value.split('\n').map(s=>s.trim()).filter(Boolean);
      if(!raw.length){toastCenter('Inserisci almeno una riga');return}

      // Tokenize (salta //)
      let tokens=[];
      for(const line of raw){
        if(/^https?:\/\//i.test(line)){
          const resolved=await resolveIfShort(line);
          const seg=extractDirSegmentKeepLeading(resolved);
          if(!seg){toastCenter('Link non valido: manca /maps/dir/');return;}
          let parts=seg.split('/'); 
          parts=parts.filter(x=>x!==''); 
          parts=parts.map(decodeTok).filter(Boolean);
          tokens.push(...parts);
        }else{
          if(line!=='//') tokens.push(line);
        }
      }
      // Geocoding con salta-errori (1:1 PS)
      const ordered = [], skipped = [], usedFallback = [];  // <-- AGGIUNTO
      for (let i = 0; i < tokens.length; i++) {
        document.getElementById('stats2').textContent = `Geocoding ${i+1}/${tokens.length}...`;
        const tok = tokens[i];
      
        // --- POI hard-coded (match prima del geocode) ---
        let fixed = null;
        for (const poi of POI_FIX) {
          if (poi.match(tok)) { 
            fixed = { lat: poi.lat, lon: poi.lon, label: poi.label };
            // se vuoi conteggiarli come “fallback”, registra il nome
            usedFallback.push(poi.label);                 // <-- facoltativo
            break;
          }
        }
        if (fixed) { ordered.push(fixed); continue; }
      
        const g = await geocodeFreeform(tok);
        if (!g) { skipped.push(tok); continue; }
        ordered.push(g);
      }
      if(ordered.length<2){ document.getElementById('stats2').textContent='Errore: geocoding fallito (troppi pochi punti).'; return; }
      if(skipped.length){ toastCenter(`Saltati ${skipped.length} punto/i non geocodificati: ${skipped.join(' · ')}`); }
      if (usedFallback.length) {
        toastCenter(`Geocodificati con fallback (verifica): ${usedFallback.join(' · ')}`);
      }
      // OSRM con coppie lon,lat ARROTONDATE A 6 (come PS)
      const coordsParam = ordered.map(p => `${p.lon},${p.lat}`).join(';');
      // radius fisso per ogni punto (metri) — solo per questo test
      //const radiusesParam = new Array(ordered.length).fill(1000).join(';');
      //const osrmUrl =
        //`${CONFIG.workerBase}/osrm?coords=${encodeURIComponent(coordsParam)}` +
        //`&profile=driving&overview=full&geometries=geojson&steps=true` +
        //`&radiuses=${encodeURIComponent(radiusesParam)}`;
      const osrmUrl =
        `${CONFIG.workerBase}/osrm?coords=${encodeURIComponent(coordsParam)}` +
        `&profile=driving&overview=full&geometries=geojson&steps=true`;
      document.getElementById('stats2').textContent='Calcolo rotta (OSRM)...';
      let osrm; try{ osrm=await getJSON(osrmUrl); }catch(e){ toastCenter('Errore OSRM'); document.getElementById('stats2').textContent='Errore: OSRM'; return; }
      if(!osrm || osrm.code!=='Ok' || !osrm.routes || !osrm.routes[0]){ toastCenter('OSRM non ha restituito una rotta valida'); document.getElementById('stats2').textContent='Errore: OSRM'; return; }

      // Steps RTE: includi tutti i maneuver (depart/arrive compresi) con dedup adiacente 1e-7 (1:1 PS)
      const rte=[];
      for(const leg of (osrm.routes[0].legs||[])){
        for(const step of (leg.steps||[])){
          if(step.maneuver && Array.isArray(step.maneuver.location)){
            const lon=String(step.maneuver.location[0]), lat=String(step.maneuver.location[1]);
            if(rte.length){
              const last=rte[rte.length-1];
              if(Math.abs(parseFloat(last.lat)-parseFloat(lat))<1e-7 && Math.abs(parseFloat(last.lon)-parseFloat(lon))<1e-7) continue;
            }
            rte.push({lat,lon,type:String(step.maneuver.type||'')});
          }
        }
      }

      // TRK
      const trk=(osrm.routes[0].geometry && osrm.routes[0].geometry.coordinates)?osrm.routes[0].geometry.coordinates:[];
      const startLabel=fileNameSafe(await reverseShortLabel(ordered[0].lat,ordered[0].lon));
      const endLabel=fileNameSafe(await reverseShortLabel(ordered[ordered.length-1].lat,ordered[ordered.length-1].lon));
      const title=`GPX da: ${startLabel} a: ${endLabel}`;
      const ts=nowStamp();

      gpxRTE=buildGPX_RTE_WPT(ordered,rte,title);
      gpxTRK=buildGPX_TRK_WPT(ordered,trk,title);
      nameRTE=`maps2gpx_osrm_rotta_${startLabel}_${endLabel}_${ts}.gpx`;
      nameTRK=`maps2gpx_osrm_traccia_${startLabel}_${endLabel}_${ts}.gpx`;

      document.getElementById('stats2').textContent=`${ordered.length} punti convertiti (WPT) · RTE ${rte.length} step · TRK ${trk.length} vertici`;

      const prevR=gpxRTE.split('\n').slice(0,200).join('\n'); document.getElementById('gpxPreviewRte').textContent=prevR+(gpxRTE.length>prevR.length?'\n...':''); document.getElementById('previewWrapRte').hidden=false;
      const prevT=gpxTRK.split('\n').slice(0,200).join('\n'); document.getElementById('gpxPreviewTrk').textContent=prevT+(gpxTRK.length>prevT.length?'\n...':''); document.getElementById('previewWrapTrk').hidden=false;
      document.getElementById('dlRow').style.display='';
      toastCenter('GPX RTE & TRK pronti');
    });

    function downloadBlob(name, content, mime){
      // Manteniamo newline finale se presente (PS style)
      const out = content.endsWith('\n') ? content : (content + '\n');
      const bytes=new TextEncoder().encode(out);
      const url=URL.createObjectURL(new Blob([bytes],{type:mime||'application/gpx+xml'}));
      const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }
    document.getElementById('btnDownloadRTE').addEventListener('click',async()=>{ if(!gpxRTE){toastCenter('Nessun GPX RTE');return} const ok=await confirmAction('Scaricare il file GPX della rotta (WPT+RTE)?'); if(!ok)return; downloadBlob(nameRTE||`maps2gpx_rotta_${nowStamp()}.gpx`,gpxRTE,'application/gpx+xml'); toast('Download avviato'); });
    document.getElementById('btnDownloadTRK').addEventListener('click',async()=>{ if(!gpxTRK){toastCenter('Nessun GPX TRK');return} const ok=await confirmAction('Scaricare il file GPX della traccia (WPT+TRK)?'); if(!ok)return; downloadBlob(nameTRK||`maps2gpx_traccia_${nowStamp()}.gpx`,gpxTRK,'application/gpx+xml'); toast('Download avviato'); });
    document.getElementById('btnClear2').addEventListener('click',()=>{ document.getElementById('maps2gpxInput').value=''; resetMaps2GPXUI(); document.getElementById('stats2').textContent='Pulito.'; });

    // ===== TAB 3: GPX -> Google Maps =====
    let gpxParsed = null; // { wpt: [{lat,lon}], rte: [...], trk: [...] }
    
    async function readFileText(file){
      if(!file) return '';
      return await new Promise((res,rej)=>{
        const fr=new FileReader();
        fr.onload=()=>res(String(fr.result||''));
        fr.onerror=()=>rej(fr.error||new Error('read error'));
        fr.readAsText(file);
      });
    }
    
    // selezione robusta indipendente dal namespace
    function getByLocalName(doc, local){
      // Prova diretta
      let arr = Array.from(doc.getElementsByTagName(local));
      // Fallback namespace wildcard
      if(!arr.length && doc.getElementsByTagNameNS){
        try { arr = Array.from(doc.getElementsByTagNameNS('*', local)); } catch {}
      }
      // Estremo fallback: scorri tutto e confronta localName
      if(!arr.length){
        arr = Array.from(doc.getElementsByTagName('*')).filter(el => (el.localName||'').toLowerCase()===local.toLowerCase());
      }
      return arr;
    }
    
    function parseGPXText(xmlText){
      const out = { wpt: [], rte: [], trk: [] };
      if(!xmlText || !xmlText.trim()) return out;
    
      let doc;
      try{
        const p = new DOMParser();
        doc = p.parseFromString(xmlText, 'application/xml');
        const pe = doc.getElementsByTagName('parsererror')[0];
        if(pe) throw new Error('XML non valido');
      }catch{
        return out;
      }
    
      // WPT
      for(const el of getByLocalName(doc,'wpt')){
        const lat = el.getAttribute('lat'), lon = el.getAttribute('lon');
        if(lat!=null && lon!=null) out.wpt.push({lat:fmt6s(lat), lon:fmt6s(lon)});
      }
    
      // RTE (tutte le <rtept> in ordine)
      for(const el of getByLocalName(doc,'rtept')){
        const lat = el.getAttribute('lat'), lon = el.getAttribute('lon');
        if(lat!=null && lon!=null) out.rte.push({lat:fmt6s(lat), lon:fmt6s(lon)});
      }
    
      // TRK (tutti i <trkpt> in ordine)
      for(const el of getByLocalName(doc,'trkpt')){
        const lat = el.getAttribute('lat'), lon = el.getAttribute('lon');
        if(lat!=null && lon!=null) out.trk.push({lat:fmt6s(lat), lon:fmt6s(lon)});
      }
    
      return out;
    }
    
    function partsFromPoints(points){
      // Costruisce array per /maps/dir/ con blank iniziale + "lat,lon"
      // Dedup adiacente su token stringa.
      let all = [''];
      for(const p of points){ all.push(`${p.lat},${p.lon}`); }
      all = dedupeAdjacent(all);
      return all;
    }
    
    function renderOutput3(urls){
      const out = document.getElementById('output3');
      const stats = document.getElementById('stats3');
      out.innerHTML = '';
      if(!urls.length){
        stats.textContent = 'Nessun risultato.';
        document.getElementById('btnDownloadAll3').style.display='none';
        return;
      }
      const n=urls.length;
      stats.textContent = (n===1?'1 link generato':`${n} link generati`) + ` · aggiornato alle ${timeHHMMSS()}`;
      for(const u of urls){
        const div=document.createElement('div'); div.className='out-item';
        div.innerHTML=`<div style="display:flex;justify-content:space-between;gap:10px;align-items:center;">
          <div class="mono" style="flex:1 1 auto;">${u}</div>
          <div class="row" style="flex:0 0 auto;">
            <button class="btn small ghost" data-copy>Copia</button>
            <button class="btn small" data-open>Apri</button>
          </div>
        </div>`;
        div.querySelector('[data-copy]').addEventListener('click', async()=>{
          await navigator.clipboard.writeText(u); toast('URL copiato');
        });
        div.querySelector('[data-open]').addEventListener('click', async()=>{
          const ok=await confirmAction('Aprire il link in una nuova scheda?'); if(ok) window.open(u,'_blank','noopener');
        });
        out.appendChild(div);
      }
      document.getElementById('btnDownloadAll3').style.display='';
      toastCenter(`Risultati aggiornati (${n} link)`);
    }
    
    async function makeLinksFrom(points){
      if(!points || points.length<1){ toastCenter('Servono almeno 1-2 punti'); return; }
    
      let all = partsFromPoints(points); // ['','lat,lon',...]
      if(all.length<=25){ renderOutput3(['https://www.google.com/maps/dir/'+all.join('/')]); return; }
    
      // Troppi punti: usa la stessa modale del Tab 1
      const dlg=document.getElementById('strategyDialog'); dlg.showModal();
      const strategy=await new Promise(r=>dlg.addEventListener('close',()=>r(dlg.returnValue==='opt'?'optimize':dlg.returnValue==='split'?'split':null),{once:true}));
      if(!strategy){ toastCenter('Operazione annullata'); return; }
    
      if(strategy==='optimize'){
        all = optimizeTo25(all);
        renderOutput3(['https://www.google.com/maps/dir/'+all.join('/')]);
      }else{
        const blocks = splitInBlocks(all); // solo il primo mantiene "" all'inizio
        renderOutput3(blocks.map(b=>'https://www.google.com/maps/dir/'+b.join('/')));
      }
    }
    
    function refreshButtonsVisibility(){
      const btns = document.getElementById('whichButtons');
      if(!gpxParsed){ btns.style.display='none'; return; }
      const wptN = (gpxParsed.wpt||[]).length;
      const rteN = (gpxParsed.rte||[]).length;
      const trkN = (gpxParsed.trk||[]).length;
      // Mostra contenitore se c'è almeno un set con >=2 punti utili
      const any = (wptN>=2) || (rteN>=2) || (trkN>=2);
      btns.style.display = any ? '' : 'none';
    
      const bW=document.getElementById('btnMakeWPT');
      const bR=document.getElementById('btnMakeRTE');
      const bT=document.getElementById('btnMakeTRK');
    
      bW.style.display = wptN?'' : 'none';
      bR.style.display = rteN?'' : 'none';
      bT.style.display = trkN?'' : 'none';
    
      if(wptN) bW.textContent = `Crea link da WPT (${wptN})`;
      if(rteN) bR.textContent = `Crea link da RTE (${rteN})`;
      if(trkN) bT.textContent = `Crea link da TRK (${trkN})`;
    }
    
    document.getElementById('btnParseGPX').addEventListener('click', async ()=>{
      const file = document.getElementById('gpxFile').files[0]||null;
      const pasted = document.getElementById('gpxText').value;
    
      let text = pasted && pasted.trim() ? pasted : '';
      if(!text && file){
        try{ text = await readFileText(file); }catch{ toastCenter('Errore lettura file'); return; }
      }
      if(!text){ toastCenter('Seleziona un file GPX o incolla il contenuto.'); return; }
    
      gpxParsed = parseGPXText(text);
      const w=(gpxParsed.wpt||[]).length, r=(gpxParsed.rte||[]).length, t=(gpxParsed.trk||[]).length;
      document.getElementById('stats3').textContent = `Trovati: WPT ${w} · RTE ${r} · TRK ${t}`;
      refreshButtonsVisibility();
      document.getElementById('output3').innerHTML='';
      document.getElementById('btnDownloadAll3').style.display='none';
    
      if(w<2 && r<2 && t<2){
        toastCenter('Attenzione: meno di 2 punti per tutte le sezioni.');
      }else{
        toastCenter('Analisi GPX completata.');
      }
    });
    
    document.getElementById('btnMakeWPT').addEventListener('click', ()=>{ if(gpxParsed) makeLinksFrom(gpxParsed.wpt); });
    document.getElementById('btnMakeRTE').addEventListener('click', ()=>{ if(gpxParsed) makeLinksFrom(gpxParsed.rte); });
    document.getElementById('btnMakeTRK').addEventListener('click', ()=>{ if(gpxParsed) makeLinksFrom(gpxParsed.trk); });
    
    document.getElementById('btnDownloadAll3').addEventListener('click', async ()=>{
      const items=[...document.querySelectorAll('#output3 .out-item .mono')].map(x=>x.textContent);
      if(!items.length) return;
      const ok=await confirmAction('Scaricare un file .txt con i link generati?'); if(!ok) return;
      const name=(items.length===1?`gpx2maps_1_${nowStamp()}.txt`:`gpx2maps_${items.length}_${nowStamp()}.txt`);
      const sep=items.length>1?'\n\n':'\n';
      const bytes=new TextEncoder().encode(items.join(sep));
      const url=URL.createObjectURL(new Blob([bytes],{type:'text/plain'}));
      const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      toast('File scaricato');
    });
    
    document.getElementById('btnClear3').addEventListener('click', ()=>{
      document.getElementById('gpxFile').value='';
      document.getElementById('gpxText').value='';
      document.getElementById('stats3').textContent='Pulito.';
      document.getElementById('output3').innerHTML='';
      document.getElementById('btnDownloadAll3').style.display='none';
      document.getElementById('whichButtons').style.display='none';
      gpxParsed=null;
    });

    // ===== TAB 4: Sanitizza GPX =====
    (function(){
      const $in  = ()=>document.getElementById('sanitizeInput');
      const $f   = ()=>document.getElementById('sanitizeFile');
      const $st  = ()=>document.getElementById('stats4');
      const $preW= ()=>document.getElementById('previewWrapSan');
      const $pre = ()=>document.getElementById('gpxPreviewSan');
      const $dlW = ()=>document.getElementById('dlRow4');
      const $btnDl=()=>document.getElementById('btnDownloadSan');
    
      let sanitizedText = '';
      let sanitizedName = '';
    
      function resetSanUI(){
        $st().textContent='Nessun file sanificato.';
        $pre().textContent='';
        $preW().hidden=true;
        $dlW().style.display='none';
        sanitizedText='';
        sanitizedName='';
      }
    
      // Core: arrotonda lat/lon, dedupe adiacente, LF only, UTF-8 on download
      function sanitizeGPX(raw){
        // forza LF e rimuove eventuale BOM
        let txt = String(raw).replace(/^\uFEFF/, '').replace(/\r\n?/g, '\n');
    
        // parse XML
        const parser = new DOMParser();
        const doc = parser.parseFromString(txt, 'application/xml');
        if(doc.querySelector('parsererror')){
          throw new Error('XML non valido (parsererror)');
        }
        const root = doc.documentElement;
        if(!root || root.nodeName.toLowerCase()!=='gpx') throw new Error('File non GPX');
    
        const stats = {
          wpt:0, rtept:0, trkpt:0,
          normalized:0,
          dropped:{ wpt:0, rtept:0, trkpt:0 }
        };
    
        // arrotonda attributi lat/lon
        function roundLatLon(el){
          const hasLat = el.hasAttribute('lat');
          const hasLon = el.hasAttribute('lon');
          if(!hasLat || !hasLon) return false;
          const latRaw = el.getAttribute('lat');
          const lonRaw = el.getAttribute('lon');
          // normalizza numeri strani
          const toNum = v => {
            const s = String(v).trim().replace(',', '.');
            const n = Number(s);
            return isFinite(n) ? n : NaN;
          };
          const latNum = toNum(latRaw);
          const lonNum = toNum(lonRaw);
          if(isNaN(latNum) || isNaN(lonNum)) return false;
    
          const lat = fmt6s(latNum);
          const lon = fmt6s(lonNum);
    
          if(el.getAttribute('lat')!==lat){ el.setAttribute('lat', lat); stats.normalized++; }
          if(el.getAttribute('lon')!==lon){ el.setAttribute('lon', lon); stats.normalized++; }
          return true;
        }
    
        // conta e round su wpt/rtept/trkpt
        const wpts = Array.from(doc.getElementsByTagName('wpt'));
        wpts.forEach(el=>{ stats.wpt++; roundLatLon(el); });
    
        const rtes = Array.from(doc.getElementsByTagName('rte'));
        rtes.forEach(rte=>{
          const pts = Array.from(rte.getElementsByTagName('rtept'));
          pts.forEach(el=>{ stats.rtept++; roundLatLon(el); });
        });
    
        const trks = Array.from(doc.getElementsByTagName('trk'));
        trks.forEach(trk=>{
          const segs = Array.from(trk.getElementsByTagName('trkseg'));
          segs.forEach(seg=>{
            const pts = Array.from(seg.getElementsByTagName('trkpt'));
            pts.forEach(el=>{ stats.trkpt++; roundLatLon(el); });
          });
        });
    
        // dedupe adiacente conservativo
        function dedupeAdjacent(list, kind, parent){
          if(list.length<=1) return;
          let prev = list[0];
          for(let i=1;i<list.length;i++){
            const cur = list[i];
            const same = prev.getAttribute('lat')===cur.getAttribute('lat')
                      && prev.getAttribute('lon')===cur.getAttribute('lon');
            if(same){
              parent.removeChild(cur);
              stats.dropped[kind]++;
            }else{
              prev = cur;
            }
          }
        }
    
        // WPT: dedupe solo su sequenze adiacenti a livello root
        {
          const children = Array.from(root.children);
          let run = [];
          for(const ch of children){
            if(ch.tagName && ch.tagName.toLowerCase()==='wpt') run.push(ch);
            else{
              if(run.length) dedupeAdjacent(run, 'wpt', root);
              run = [];
            }
          }
          if(run.length) dedupeAdjacent(run, 'wpt', root);
        }
    
        // RTE: per ogni rte, dedupe sulla lista diretta di rtept
        rtes.forEach(rte=>{
          const pts = Array.from(rte.children).filter(n=>n.tagName && n.tagName.toLowerCase()==='rtept');
          if(pts.length) dedupeAdjacent(pts, 'rtept', rte);
        });
    
        // TRK: per ogni trkseg, dedupe sulla lista diretta di trkpt
        trks.forEach(trk=>{
          const segs = Array.from(trk.getElementsByTagName('trkseg'));
          segs.forEach(seg=>{
            const pts = Array.from(seg.children).filter(n=>n.tagName && n.tagName.toLowerCase()==='trkpt');
            if(pts.length) dedupeAdjacent(pts, 'trkpt', seg);
          });
        });
    
        // Serializza, forza intestazione XML UTF-8, LF-only, newline finale
        let body = new XMLSerializer().serializeToString(doc);
        body = body.replace(/^\s*<\?xml[\s\S]*?\?>\s*/,''); // togli eventuale vecchia declaration
        let out = `<?xml version="1.0" encoding="UTF-8"?>\n` + body;
        out = out.replace(/\r\n?/g, '\n');
        if(!out.endsWith('\n')) out += '\n';
    
        return { text: out, stats };
      }
    
      // UI handlers
      document.getElementById('btnSanitize').addEventListener('click', ()=>{
        const raw = $in().value.trim();
        if(!raw){ toastCenter('Incolla un GPX o apri un file'); return; }
        try{
          const {text, stats} = sanitizeGPX(raw);
          sanitizedText = text;
          sanitizedName = `gpx_sanitizzato_${nowStamp()}.gpx`;
    
          $st().textContent =
            `WPT ${stats.wpt} · RTEPT ${stats.rtept} · TRKPT ${stats.trkpt} · `+
            `Normalizzati ${stats.normalized} · Duplicati rimossi: `+
            `WPT ${stats.dropped.wpt}, RTE ${stats.dropped.rtept}, TRK ${stats.dropped.trkpt}`;
          const prev = text.split('\n').slice(0,200).join('\n');
          $pre().textContent = prev + (text.length>prev.length?'\n...':'');
          $preW().hidden = false;
          $dlW().style.display = '';
          toastCenter('Sanitizzazione completata (LF + UTF-8)');
        }catch(e){
          console.error(e);
          toastCenter('Errore di parsing GPX: verifica il file');
          resetSanUI();
        }
      });
    
      document.getElementById('btnDownloadSan').addEventListener('click', async ()=>{
        if(!sanitizedText){ toastCenter('Nessun file sanificato'); return; }
        const ok = await confirmAction('Scaricare il file GPX sanificato?');
        if(!ok) return;
        // Forziamo charset UTF-8; LF già garantito dal testo
        const bytes = new TextEncoder().encode(sanitizedText.endsWith('\n') ? sanitizedText : (sanitizedText+'\n'));
        const url = URL.createObjectURL(new Blob([bytes], {type:'application/gpx+xml; charset=utf-8'}));
        const a=document.createElement('a'); a.href=url; a.download=(sanitizedName||`gpx_sanitizzato_${nowStamp()}.gpx`);
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
        toastCenter('Download avviato');
      });
    
      document.getElementById('btnClear4').addEventListener('click', ()=>{
        $in().value=''; $f().value=''; resetSanUI(); $st().textContent='Pulito.';
      });
    
      document.getElementById('sanitizeFile').addEventListener('change', async (e)=>{
        const file = e.target.files && e.target.files[0];
        if(!file) return;
        const txt = await file.text(); // UTF-8 by default
        $in().value = txt;
        toastCenter(`Caricato: ${file.name}`);
      });
    })();
    /* ===== TAB 5: Meteo (PS-style) ===== */

    // Usa le stesse helper già presenti: getJSON, resolveIfShort, extractDirSegmentKeepLeading, decodeTok,
    // isLatLonStr, geocodeTry, geocodeFreeform, fileNameSafe, nowStamp, joinLF, toastCenter, confirmAction.
    
    // Daypart (fisso come PS)
    const DAYPARTS = [
      {key:'notte',      from:0,  to:5},
      {key:'mattina',    from:6,  to:11},
      {key:'pomeriggio', from:12, to:17},
      {key:'sera',       from:18, to:23},
    ];
    
    // Mappa WMO → categoria semplice (PS-style: sole/nuvole/pioggia/neve/temporale/nebbia)
    function wmoCategory(code){
      code = Number(code);
      if ([95,96,99].includes(code)) return 'temporale';
      if ([71,73,75,77,85,86].includes(code)) return 'neve';
      if (
        [51,53,55,56,57,61,63,65,66,67,80,81,82].includes(code)
      ) return 'pioggia';
      if ([45,48].includes(code)) return 'nebbia';
      if ([1,2,3].includes(code)) return 'nuvole';
      if (code === 0) return 'sole';
      return 'nuvole';
    }
    
    // Aggrega 7 giorni x 4 fasce: per fascia solo condizione + Tmin/Tmax
    function aggregateMeteoHourly(hourly){
      // hourly: { time:[], temperature_2m:[], precipitation_probability:[], precipitation:[], weathercode:[] }
      const out = []; // [{date:'YYYY-MM-DD', parts:{ notte:{tmin,tmax,cat}, ... } }]
      if(!hourly || !hourly.time || !hourly.time.length) return out;
    
      // Gruppo per data locale
      const byDate = new Map();
      for(let i=0;i<hourly.time.length;i++){
        const t = hourly.time[i]; // ISO string in timezone locale (Open-Meteo)
        const d = t.slice(0,10);  // YYYY-MM-DD
        if(!byDate.has(d)) byDate.set(d, []);
        byDate.get(d).push({
          hour: Number(t.slice(11,13)),
          temp: Number(hourly.temperature_2m?.[i]),
          wcode: Number(hourly.weathercode?.[i]),
          pprob: Number(hourly.precipitation_probability?.[i]),
          rain: Number(hourly.precipitation?.[i]),
        });
      }
    
      for(const [date, items] of byDate){
        const parts = {};
        for(const p of DAYPARTS){
          const slice = items.filter(x=>x.hour>=p.from && x.hour<=p.to);
          if(!slice.length){ parts[p.key] = null; continue; }
          const tmin = Math.min(...slice.map(x=>x.temp));
          const tmax = Math.max(...slice.map(x=>x.temp));
          // categoria: priorità temporale > neve > pioggia > nuvole > sole
          let cat = 'sole';
          const codes = slice.map(x=>x.wcode);
          if (codes.some(c=>[95,96,99].includes(c))) cat='temporale';
          else if (codes.some(c=>[71,73,75,77,85,86].includes(c))) cat='neve';
          else if (codes.some(c=>[51,53,55,56,57,61,63,65,66,67,80,81,82].includes(c))) cat='pioggia';
          else if (codes.some(c=>[1,2,3,45,48].includes(c))) cat = (codes.some(c=>[45,48].includes(c))?'nebbia':'nuvole');
          parts[p.key] = { tmin: Math.round(tmin), tmax: Math.round(tmax), cat };
        }
        out.push({ date, parts });
        if(out.length>=7) break; // 7 giorni
      }
      return out;
    }
    
    // Template HTML (semplice e compatto, stile PS: tabellare 7×4, solo cat + Tmin/Tmax)
    function buildWeatherHTML(routeInfo, wptBlocks){
      const css = `
        body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;margin:16px;color:#0f172a;background:#fff}
        h1{font-size:20px;margin:0 0 8px;font-weight:900}
        h2{font-size:16px;margin:18px 0 6px;font-weight:800}
        .muted{color:#475569;font-size:13px}
        table{border-collapse:collapse;width:100%;margin:8px 0}
        th,td{border:1px solid #e2e8f0;padding:6px 8px;font-size:13px;text-align:center}
        th{background:#f8fafc;font-weight:800}
        .grid{display:grid;gap:16px}
        .card{border:1px solid #e2e8f0;border-radius:10px;padding:12px}
        .row{display:flex;flex-wrap:wrap;gap:8px}
        .badge{background:#f1f5f9;border:1px solid #e2e8f0;border-radius:999px;padding:2px 8px;font-size:12px}
      `;
      let H = '';
      H += `<!doctype html><html lang="it"><head><meta charset="utf-8"><title>Meteo percorso</title><style>${css}</style></head><body>`;
      H += `<h1>Meteo percorso</h1>`;
      H += `<div class="card"><div class="row">
              <div class="badge">WPT: ${routeInfo.count}</div>
              <div class="badge">Distanza: ${routeInfo.total_km} km</div>
              <div class="badge">Durata: ${routeInfo.total_hm}</div>
            </div>`;
      H += `<div class="muted" style="margin-top:6px;">Parziali: ${routeInfo.legs.join(' · ')}</div></div>`;
    
      for(const blk of wptBlocks){
        H += `<h2>${blk.title}</h2>`;
        H += `<div class="card"><table><thead><tr><th>Data</th>`;
        for(const dp of DAYPARTS) H += `<th>${dp.key}</th>`;
        H += `</tr></thead><tbody>`;
        for(const day of blk.days){
          H += `<tr><td>${day.date}</td>`;
          for(const dp of DAYPARTS){
            const cell = day.parts[dp.key];
            if(!cell){ H += `<td>-</td>`; continue; }
            H += `<td>${cell.cat}<br><strong>${cell.tmin}° / ${cell.tmax}°</strong></td>`;
          }
          H += `</tr>`;
        }
        H += `</tbody></table></div>`;
      }
    
      H += `</body></html>`;
      return H;
    }
    
    // TXT e CSV (semplici, allineati al contenuto dell'HTML)
    function buildWeatherTXT(routeInfo, wptBlocks){
      const L=[];
      L.push(`Meteo percorso`);
      L.push(`WPT: ${routeInfo.count} | Distanza: ${routeInfo.total_km} km | Durata: ${routeInfo.total_hm}`);
      L.push(`Parziali: ${routeInfo.legs.join(' · ')}`);
      L.push('');
      for(const blk of wptBlocks){
        L.push(`== ${blk.title} ==`);
        L.push(`Data;Fascia;Condizione;Tmin;Tmax`);
        for(const day of blk.days){
          for(const dp of DAYPARTS){
            const cell = day.parts[dp.key];
            if(!cell) continue;
            L.push(`${day.date};${dp.key};${cell.cat};${cell.tmin};${cell.tmax}`);
          }
        }
        L.push('');
      }
      return joinLF(L)+'\n';
    }
    function buildWeatherCSV(routeInfo, wptBlocks){
      const L=[];
      L.push(`Waypoint,Data,Fascia,Condizione,Tmin,Tmax`);
      for(const blk of wptBlocks){
        for(const day of blk.days){
          for(const dp of DAYPARTS){
            const cell = day.parts[dp.key];
            if(!cell) continue;
            // CSV semplice, separatore virgola, escape basico con doppi apici
            const safe = s => `"${String(s).replace(/"/g,'""')}"`;
            L.push([safe(blk.title), day.date, dp.key, cell.cat, cell.tmin, cell.tmax].join(','));
          }
        }
      }
      return joinLF(L)+'\n';
    }
    
    // Costruzione info percorso (totale + parziali) da OSRM
    function formatHM(sec){
      sec = Math.round(sec);
      const h = Math.floor(sec/3600), m = Math.round((sec%3600)/60);
      return (h?`${h}h `:'') + `${m}m`;
    }
    
    async function buildRouteInfo(points){
      // OSRM sui WPT (lon,lat)
      const coordsParam = points.map(p=>`${p.lon},${p.lat}`).join(';');
      const osrmUrl = `${CONFIG.workerBase}/osrm?coords=${encodeURIComponent(coordsParam)}&profile=driving&overview=false&geometries=geojson&steps=true`;
      let osrm;
      try{ osrm = await getJSON(osrmUrl); }catch{ osrm=null; }
      if(!osrm || osrm.code!=='Ok' || !osrm.routes || !osrm.routes[0]){
        return {
          count: points.length,
          total_km: '—',
          total_hm: '—',
          legs: []
        };
      }
      const route = osrm.routes[0];
      const legs = route.legs || [];
      const legStr = legs.map((lg, i)=>`WP${String(i+1).padStart(2,'0')}→WP${String(i+2).padStart(2,'0')}: ${(lg.distance/1000).toFixed(1)} km / ${formatHM(lg.duration)}`);
      return {
        count: points.length,
        total_km: (route.distance/1000).toFixed(1),
        total_hm: formatHM(route.duration),
        legs: legStr
      };
    }
    
    // UI: render file list (Apri/Scarica)
    function renderFiles5(files){
      const box = document.getElementById('files5');
      box.innerHTML = '';
      if(!files || !files.length){ box.innerHTML = '<div class="note">Niente ancora.</div>'; return; }
      for(const f of files){
        const row = document.createElement('div');
        row.className = 'out-item';
        row.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;">
            <div class="mono" style="flex:1 1 auto;">${f.name}</div>
            <div class="row" style="flex:0 0 auto;">
              ${f.openable?'<button class="btn small ghost" data-open>Apri</button>':''}
              <button class="btn small" data-dl>Scarica</button>
            </div>
          </div>`;
        const bytes = new TextEncoder().encode(f.content.endsWith('\n')?f.content:(f.content+'\n'));
        const blob = new Blob([bytes], {type: f.mime});
        const url  = URL.createObjectURL(blob);
        row.querySelector('[data-dl]').addEventListener('click', ()=>{ const a=document.createElement('a'); a.href=url; a.download=f.name; document.body.appendChild(a); a.click(); a.remove(); });
        if(f.openable){
          row.querySelector('[data-open]').addEventListener('click', ()=>{ window.open(url, '_blank', 'noopener'); });
        }
        box.appendChild(row);
      }
    }
    
    // === Handler principale ===
    document.getElementById('btnGenMeteo').addEventListener('click', async ()=>{
      document.getElementById('files5').innerHTML = '<div class="note">Elaborazione in corso…</div>';
      document.getElementById('stats5').textContent = 'Parsing input…';
    
      // 1) Leggi input
      const raw = document.getElementById('meteoInput').value.split('\n').map(s=>s.trim()).filter(Boolean);
      if(!raw.length){ toastCenter('Inserisci un link o località/coordinate'); document.getElementById('files5').innerHTML = '<div class="note">Niente ancora.</div>'; return; }
    
      // Se c’è un link, deve essercene solo UNO
      const links = raw.filter(s=>/^https?:\/\//i.test(s));
      if(links.length>1){ toastCenter('Errore: inserire un solo link Maps'); document.getElementById('files5').innerHTML = '<div class="note">Niente ancora.</div>'; return; }
    
      let tokens = [];
      if(links.length===1){
        // Risolvi shortlink e “long strani” (daddr → /dir//…)
        const resolved = await resolveIfShort(links[0]);
        const seg = extractDirSegmentKeepLeading(resolved);
        if(!seg){ toastCenter('Link non valido: manca /maps/dir/'); document.getElementById('files5').innerHTML = '<div class="note">Niente ancora.</div>'; return; }
        let parts = seg.split('/'); parts = parts.filter(x=>x!==''); parts = parts.map(decodeTok).filter(Boolean);
        tokens.push(...parts);
      }else{
        // località/coordinate a mano
        tokens = raw.slice();
      }
    
      if(tokens.length<2){ toastCenter('Servono almeno due punti'); document.getElementById('files5').innerHTML = '<div class="note">Niente ancora.</div>'; return; }
    
      // 2) Geocoding punti (1:1 PS – stesso della Tab 2)
      const points = [], skipped=[];
      for(let i=0;i<tokens.length;i++){
        document.getElementById('stats5').textContent = `Geocoding ${i+1}/${tokens.length}…`;
        const g = await geocodeFreeform(tokens[i]); // usa funzione già definita nel Tab 2 (PS minimal)
        if(!g){ skipped.push(tokens[i]); continue; }
        points.push(g);
      }
      if(points.length<2){ document.getElementById('stats5').textContent = 'Errore: troppi pochi punti geocodificati.'; document.getElementById('files5').innerHTML = '<div class="note">Niente ancora.</div>'; return; }
      if(skipped.length){ toastCenter(`Saltati ${skipped.length} punto/i non geocodificati`); }
    
      // 3) Info percorso (OSRM totale + parziali)
      document.getElementById('stats5').textContent = 'Calcolo percorso (OSRM)…';
      const routeInfo = await buildRouteInfo(points);
    
      // 4) Meteo per ciascun WPT (7d x 4 fasce)
      document.getElementById('stats5').textContent = 'Download meteo…';
      const blocks = [];
      for(let i=0;i<points.length;i++){
        const p = points[i];
        const w = await getJSON(`${CONFIG.workerBase}/weather?lat=${encodeURIComponent(p.lat)}&lon=${encodeURIComponent(p.lon)}`);
        const agg = aggregateMeteoHourly(w && w.hourly ? w.hourly : null);
        blocks.push({ title: (p.label || `${p.lat},${p.lon}`), days: agg });
      }
    
      // 5) File (HTML, TXT, CSV) — PS-style
      const ts = nowStamp();
      const html = buildWeatherHTML(routeInfo, blocks);
      const txt  = buildWeatherTXT(routeInfo, blocks);
      const csv  = buildWeatherCSV(routeInfo, blocks);
    
      const startName = fileNameSafe(blocks[0]?.title || 'start');
      const endName   = fileNameSafe(blocks[blocks.length-1]?.title || 'end');
    
      const files = [
        { name: `meteo_${startName}_to_${endName}_${ts}.html`, mime:'text/html; charset=utf-8', content: html, openable:true },
        { name: `meteo_${startName}_to_${endName}_${ts}.txt`,  mime:'text/plain; charset=utf-8', content: txt,  openable:true },
        { name: `meteo_${startName}_to_${endName}_${ts}.csv`,  mime:'text/csv; charset=utf-8',   content: csv,  openable:false },
      ];
      renderFiles5(files);
      document.getElementById('stats5').textContent = `Meteo generato per ${points.length} WPT · 7 giorni × 4 fasce`;
    
      toastCenter('Meteo pronto (HTML, TXT, CSV)');
    });
    
    document.getElementById('btnClear5').addEventListener('click', ()=>{
      document.getElementById('meteoInput').value='';
      document.getElementById('stats5').textContent='Pulito.';
      document.getElementById('files5').innerHTML='<div class="note">Niente ancora.</div>';
    });
  </script>
</body>
</html>
