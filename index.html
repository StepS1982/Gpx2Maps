Below are the complete, aligned files for the first iteration of fixes/improvements focusing on TAB 1 (Fusione Link).

---

# index.html

```html
<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GPX2MAPS Web-APP</title>
  <meta name="description" content="Software per gestire al 100% itinerati con Google Maps in modalità navigabile" />
  <style>
    :root {
      --accent: #e11d48; /* rosso per 'by Pieghello' */
      --fg: #0f172a; /* slate-900 */
      --muted: #475569; /* slate-600 */
      --bg: #f8fafc; /* slate-50 */
      --card: #ffffff;
      --border: #e2e8f0; /* slate-200 */
      --btn: #0ea5e9; /* sky-500 */
      --btn2: #22c55e; /* green-500 */
      --btnDanger: #ef4444; /* red-500 */
    }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; color: var(--fg); background: var(--bg); }
    header { padding: 20px 16px 8px; background: var(--card); border-bottom: 1px solid var(--border); }
    .hero { max-width: 1100px; margin: 0 auto; display:flex; align-items:center; gap:16px; }
    .hero img { width: 44px; height: 44px; border-radius: 10px; }
    .title { font-weight: 800; font-size: 24px; line-height: 1.1; }
    .subtitle { color: var(--accent); font-weight: 700; }
    .cta { text-align:center; margin: 12px 0 0; display:flex; justify-content:center; gap:10px; flex-wrap: wrap; }
    .btn { appearance:none; border:1px solid transparent; background: var(--btn); color:#fff; padding:10px 14px; border-radius: 999px; cursor:pointer; font-weight: 700; }
    .btn.secondary { background: var(--btn2); }
    .btn.ghost { background:#fff; color: var(--fg); border-color: var(--border); }
    .btn.small { padding:6px 10px; font-weight:600; }
    .btn.danger { background: var(--btnDanger); }
    .container { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .note { margin: 14px 0 6px; color: var(--muted); font-size: 14px; }

    /* Tabs */
    .tabs { display:flex; gap:8px; flex-wrap: wrap; border-bottom: 1px solid var(--border); margin-top: 12px; }
    .tab { padding: 10px 12px; cursor:pointer; border:1px solid var(--border); border-bottom:none; border-radius: 10px 10px 0 0; background:#f1f5f9; font-weight:700; }
    .tab.active { background:#fff; color:#0ea5e9; }

    /* Cards / sections */
    .card { background: var(--card); border:1px solid var(--border); border-radius: 14px; box-shadow: 0 1px 2px rgba(0,0,0,0.04); }
    .card .hd { padding: 14px 16px; border-bottom:1px solid var(--border); font-weight: 800; }
    .card .bd { padding: 16px; }

    .grid { display:grid; grid-template-columns: 1fr; gap: 16px; }
    @media (min-width: 900px){ .grid-2 { grid-template-columns: 1.4fr 1fr; } }

    textarea { width: 100%; min-height: 180px; resize: vertical; padding: 12px; border-radius: 10px; border:1px solid var(--border); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap: wrap; }
    .chip { display:inline-flex; align-items:center; gap:8px; border:1px solid var(--border); padding:8px 10px; border-radius: 999px; background:#fff; }
    .chip input { transform: translateY(1px); }

    .output-list { display:flex; flex-direction:column; gap:10px; }
    .out-item { border:1px dashed var(--border); border-radius: 12px; padding: 12px; background:#fff; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; word-break: break-all; }

    /* Modal */
    dialog { border: none; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); width: min(560px, 92vw); }
    dialog::backdrop { background: rgba(0,0,0,0.35); }

    /* Toasts */
    #toasts { position: fixed; right: 12px; bottom: 12px; display:flex; flex-direction:column; gap:8px; z-index: 50; }
    .toast { background: #111827; color:#fff; padding: 10px 12px; border-radius: 10px; font-size: 14px; box-shadow: 0 6px 16px rgba(0,0,0,0.28); }

    footer { margin: 36px auto 24px; max-width: 1100px; color: var(--muted); font-size: 13px; padding: 0 16px; }
  </style>
</head>
<body>
  <header>
    <div class="hero">
      <img src="/gpx2maps_icon_1024.png" alt="Logo GPX2MAPS" />
      <div>
        <div class="title">GPX2MAPS Web-APP</div>
        <div class="subtitle">by Pieghello</div>
      </div>
    </div>
    <div class="cta">
      <a id="donateBtn" class="btn" href="#" target="_blank" rel="noopener">Dona</a>
      <a id="amazonBtn" class="btn secondary" href="#" target="_blank" rel="noopener">Offerte e Coupon Amazon</a>
    </div>
  </header>

  <div class="container">
    <div class="note">Software per gestire al 100% itinerati con Google Maps in modalità navigabile</div>

    <!-- Tabs -->
    <div class="tabs" role="tablist">
      <button class="tab active" role="tab" aria-selected="true" data-tab="merge">Fusione Link</button>
      <button class="tab" role="tab" aria-selected="false" data-tab="maps2gpx">2) Google Maps → GPX</button>
      <button class="tab" role="tab" aria-selected="false" data-tab="gpx2maps">3) GPX → Google Maps</button>
      <button class="tab" role="tab" aria-selected="false" data-tab="sanitize">4) Sanitizza GPX</button>
      <button class="tab" role="tab" aria-selected="false" data-tab="meteo">5) Meteo + Info percorso</button>
    </div>

    <!-- TAB 1: Fusione Link -->
    <section id="tab-merge" class="card" aria-labelledby="Fusione Link">
      <div class="hd">Fusione, ottimizzazione e split dei link Google Maps</div>
      <div class="bd grid grid-2">
        <div>
          <label for="linksInput" style="font-weight:800;">Incolla i link (uno per riga)</label>
          <textarea id="linksInput" placeholder="Esempi accettati:\n- https://maps.app.goo.gl/xxxxx\n- https://www.google.com/maps/dir/…\n- https://goo.gl/maps/…\n- https://www.google.com/maps/place/…/@lat,lon,…\n- Indirizzo libero o coordinate lat,lon"></textarea>

          <div class="row" style="margin-top:10px;">
            <label class="chip"><input type="checkbox" id="chkDedupe" /> <span>Rimuovi duplicati (opzionale)</span></label>
            <label class="chip"><input type="checkbox" id="chkAddCurrent" checked /> <span>Aggiungi // all'inizio se manca (solo 1 punto)</span></label>
            <label class="chip"><input type="checkbox" id="chkSanitize" checked /> <span>Sanitizza URL (rimuovi da /@ in poi)</span></label>
          </div>

          <div class="row" style="margin-top:12px;">
            <button id="btnMerge" class="btn">Analizza e Unisci</button>
            <button id="btnClear" class="btn ghost">Pulisci</button>
          </div>
        </div>

        <div>
          <div class="out card">
            <div class="hd">Risultati</div>
            <div class="bd">
              <div id="stats" class="note">Nessun risultato ancora.</div>
              <div id="output" class="output-list"></div>
              <div class="row" style="margin-top:10px;">
                <button id="btnOpenAll" class="btn small" style="display:none;">Apri tutti</button>
                <button id="btnDownloadAll" class="btn small" style="display:none;">Scarica .txt</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Altri tab: placeholder per mantenere l'ordine e l'UI, saranno completati nei passaggi successivi -->
    <section id="tab-maps2gpx" class="card" hidden>
      <div class="hd">2) Google Maps → GPX</div>
      <div class="bd">In arrivo nel prossimo step. Manteniamo l'ordine richiesto.</div>
    </section>
    <section id="tab-gpx2maps" class="card" hidden>
      <div class="hd">3) GPX → Google Maps</div>
      <div class="bd">In arrivo.</div>
    </section>
    <section id="tab-sanitize" class="card" hidden>
      <div class="hd">4) Sanitizza GPX</div>
      <div class="bd">In arrivo.</div>
    </section>
    <section id="tab-meteo" class="card" hidden>
      <div class="hd">5) Meteo + Info percorso</div>
      <div class="bd">In arrivo.</div>
    </section>
  </div>

  <footer>
    L'applicazione è stata realizzata a scopo gratuito per la comunità. Se si vuole fare un'opera di gentilezza nei confronti dello sviluppatore che ci ha perso del tempo per realizzarla, si prega di effettuare una donazione con il pulsante ‘Dona’ in alto. Approfitta anche del link diretto alla pagina nascosta di Amazon con tutte le offerte e coupon, che è accessibile con il pulsante che si trova sempre in alto.
  </footer>

  <!-- Confirm Modal -->
  <dialog id="confirmDialog">
    <form method="dialog" style="padding:18px 18px 8px;">
      <h3 style="margin:0 0 6px; font-weight:900;">Confermi l'operazione?</h3>
      <p id="confirmText" style="margin:0 0 14px; color:var(--muted);"></p>
      <div class="row" style="justify-content:flex-end;">
        <button class="btn ghost" value="cancel">Annulla</button>
        <button class="btn" value="ok">Conferma</button>
      </div>
    </form>
  </dialog>

  <!-- Strategy Modal (quando >25 punti) -->
  <dialog id="strategyDialog">
    <form method="dialog" style="padding:18px 18px 8px;">
      <h3 style="margin:0 0 6px; font-weight:900;">Troppi punti per un singolo link</h3>
      <p style="margin:0 0 10px; color:var(--muted);">Hai superato il limite di 25 (incluso "//"). Scegli una strategia:</p>
      <div class="row" style="flex-direction:column; align-items:stretch; gap:10px;">
        <button id="btnStrategyOptimize" class="btn" value="opt">1) Ottimizza a 25 mantenendo il primo ("//" se presente), l'ultimo e distribuendo equamente gli intermedi</button>
        <button id="btnStrategySplit" class="btn secondary" value="split">2) Suddividi in più link da massimo 25 punti (solo il primo inizia con "//")</button>
      </div>
      <div class="row" style="justify-content:flex-end; margin-top:10px;">
        <button class="btn ghost" value="cancel">Chiudi</button>
      </div>
    </form>
  </dialog>

  <div id="toasts" aria-live="polite" aria-atomic="true"></div>

  <script>
    // === CONFIG costanti richieste ===
    const CONFIG = {
      workerBase: "https://gpx2maps-worker.stefano-vitro.workers.dev",
      paypalDonateUrl: "https://www.paypal.com/donate?business=stefano.vitro%40gmail.com&no_recurring=0&item_name=Supporto+sviluppo+GPX2MAPS&currency_code=EUR",
      amazonAffiliateUrl: "https://amzn.to/41o2XjA",
    };

    // Inizializza CTA
    document.getElementById('donateBtn').href = CONFIG.paypalDonateUrl;
    document.getElementById('amazonBtn').href = CONFIG.amazonAffiliateUrl;

    // Tabs switching (manteniamo l'ordine richiesto)
    const tabs = document.querySelectorAll('.tab');
    tabs.forEach(btn => btn.addEventListener('click', () => {
      tabs.forEach(b => { b.classList.remove('active'); b.setAttribute('aria-selected','false'); });
      btn.classList.add('active'); btn.setAttribute('aria-selected','true');
      const id = btn.dataset.tab;
      ['merge','maps2gpx','gpx2maps','sanitize','meteo'].forEach(key => {
        const sec = document.getElementById(`tab-${key}`);
        if (sec) sec.hidden = key !== id && !(key==='merge' && id===undefined); // default merge
      });
    }));

    // Toast util
    function toast(msg){
      const t = document.createElement('div');
      t.className = 'toast';
      t.textContent = msg;
      document.getElementById('toasts').appendChild(t);
      setTimeout(() => t.remove(), 3400);
    }

    // Confirm modal wrapper
    async function confirmAction(text){
      const dlg = document.getElementById('confirmDialog');
      document.getElementById('confirmText').textContent = text || '';
      dlg.showModal();
      const val = await new Promise(res => dlg.addEventListener('close', () => res(dlg.returnValue), { once:true }));
      return val === 'ok';
    }

    // Strategy modal wrapper
    async function chooseStrategy(){
      const dlg = document.getElementById('strategyDialog');
      dlg.showModal();
      const v = await new Promise(res => dlg.addEventListener('close', () => res(dlg.returnValue), { once:true }));
      if (v === 'opt') return 'optimize';
      if (v === 'split') return 'split';
      return null;
    }

    // Helper: fetch JSON with simple error trap
    async function getJSON(url){
      const r = await fetch(url, { headers: { 'Accept':'application/json' } });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }

    // Parsing funzioni per Google Maps
    function stripAfterAt(urlStr){
      // rimuove da "/@" in poi, o da "/data=" in poi, o query/hash
      const idxAt = urlStr.indexOf('/@');
      const idxData = urlStr.indexOf('/data=');
      let cut = urlStr;
      if (idxAt !== -1) cut = cut.substring(0, idxAt);
      if (idxData !== -1) cut = cut.substring(0, idxData);
      // rimuovi query/hash
      try {
        const u = new URL(cut);
        cut = `${u.origin}${u.pathname}`;
      } catch { /* ignore */ }
      return cut;
    }

    function extractLatLonFromAt(pathname){
      // cerca segmento che inizia con '@lat,lon'
      const segs = pathname.split('/');
      for (const s of segs){
        if (s.startsWith('@')){
          const parts = s.slice(1).split(',');
          const lat = parseFloat(parts[0]);
          const lon = parseFloat(parts[1]);
          if (Number.isFinite(lat) && Number.isFinite(lon)){
            return `${lat},${lon}`;
          }
        }
      }
      return null;
    }

    function decodePathSegments(raw){
      return raw.split('/').filter(Boolean).map(s => decodeURIComponent(s));
    }

    function extractPointsFromUrl(input){
      // Returns array of points (strings). May include "//".
      // If plain address or raw 'lat,lon', return [input]
      const s = input.trim();
      if (!/^https?:\/\//i.test(s)){
        return [s];
      }
      try {
        const u = new URL(s);
        const host = u.host;
        const pathname = decodeURIComponent(u.pathname);

        // /dir/ path
        const idx = pathname.indexOf('/maps/dir/');
        if (idx !== -1){
          const after = pathname.substring(idx + '/maps/dir/'.length);
          // stop at '/data=' if present
          const dataIdx = after.indexOf('/data=');
          const core = dataIdx !== -1 ? after.substring(0, dataIdx) : after;
          const pts = core.split('/').filter(Boolean).map(x => x === '' ? '' : x);
          return pts.length ? pts : [];
        }

        // classic '/dir/' (sometimes no '/maps')
        const idx2 = pathname.indexOf('/dir/');
        if (idx2 !== -1){
          const after = pathname.substring(idx2 + '/dir/'.length);
          const dataIdx = after.indexOf('/data=');
          const core = dataIdx !== -1 ? after.substring(0, dataIdx) : after;
          const pts = core.split('/').filter(Boolean);
          return pts.length ? pts : [];
        }

        // /place/ with @lat,lon
        if (pathname.includes('/place/')){
          const ll = extractLatLonFromAt(pathname);
          if (ll) return [ll];
          // fallback to last non-empty segment as name
          const segs = decodePathSegments(pathname);
          const name = segs[segs.length-1] || segs[segs.length-2];
          if (name && name !== 'place') return [name];
        }

        // maps?q=lat,lon or q=address
        if (u.searchParams.has('q')){
          const q = u.searchParams.get('q');
          if (q) return [q];
        }

        // @lat,lon anywhere
        const ll2 = extractLatLonFromAt(pathname);
        if (ll2) return [ll2];

        // unknown maps URL -> fallback to stripped path
        return [stripAfterAt(s)];
      } catch {
        return [s];
      }
    }

    function sanitizePointToken(tok){
      if (tok === '//') return tok;
      // remove stray '/@...' from token-like inputs
      if (/^https?:/i.test(tok)){
        return stripAfterAt(tok);
      }
      return tok.trim();
    }

    function buildDirectionsURL(points){
      const base = 'https://www.google.com/maps/dir/';
      const enc = points.map(p => encodeURIComponent(p));
      return base + enc.join('/');
    }

    function dedupeOrdered(list){
      const seen = new Set();
      const out = [];
      for (const x of list){
        const key = x.toLowerCase();
        if (!seen.has(key)) { seen.add(key); out.push(x); }
      }
      return out;
    }

    function evenSample(inner, need){
      // sample 'inner' to length 'need' as evenly as possible
      if (need <= 0) return [];
      if (inner.length <= need) return inner.slice();
      const out = [];
      for (let i = 0; i < need; i++){
        const idx = Math.round(i * (inner.length - 1) / (need - 1));
        out.push(inner[idx]);
      }
      // remove accidental duplicates if any rounding collisions
      const res = [];
      for (const v of out){ if (res[res.length-1] !== v) res.push(v); }
      while (res.length > need) res.pop();
      return res;
    }

    function optimizeTo25(points){
      const MAX = 25;
      if (points.length <= MAX) return points;
      const hasSlash = points[0] === '//';
      const first = points[0];
      const last = points[points.length - 1];
      let inner = points.slice(hasSlash ? 1 : 1, points.length - 1);
      const capacity = MAX - 2 - (hasSlash ? 0 : 0);
      const sampled = evenSample(inner, capacity);
      const out = [first, ...sampled, last];
      // If no '//' in first, still fine
      return out.slice(0, MAX);
    }

    function splitInBlocks(points){
      const MAX = 25;
      const blocks = [];
      const hasSlash = points[0] === '//';
      if (hasSlash){
        // block 1 keeps '//'
        const b1 = points.slice(0, MAX);
        blocks.push(b1);
        let rest = points.slice(MAX);
        while (rest.length){
          // subsequent blocks: drop leading '//' if present in rest
          if (rest[0] === '//') rest = rest.slice(1);
          const b = rest.slice(0, MAX);
          blocks.push(b);
          rest = rest.slice(MAX);
        }
      } else {
        let rest = points.slice();
        while (rest.length){
          const b = rest.slice(0, MAX);
          blocks.push(b);
          rest = rest.slice(MAX);
        }
      }
      // ensure only first block starts with '//' if any
      for (let i=1;i<blocks.length;i++){
        if (blocks[i][0] === '//') blocks[i].shift();
      }
      return blocks;
    }

    async function resolveIfShort(url){
      if (!/^https?:\/\//i.test(url)) return url;
      const h = (new URL(url)).host;
      const isShort = /(^|\.)(maps\.app\.goo\.gl|goo\.gl|g\.co)$/i.test(h) || /(^|\.)goo\.gl$/i.test(h) || /(^|\.)g\.co$/i.test(h) || /(^|\.)goo\.gl$/i.test(h) || /(^|\.)goo\.gl$/i.test(h);
      if (!isShort) return url;
      try {
        const { finalUrl } = await getJSON(`${CONFIG.workerBase}/resolve?url=${encodeURIComponent(url)}`);
        return finalUrl || url;
      } catch {
        return url; // fallback
      }
    }

    function renderOutput(urls){
      const out = document.getElementById('output');
      const stats = document.getElementById('stats');
      out.innerHTML = '';
      if (!urls.length){
        stats.textContent = 'Nessun risultato.';
        document.getElementById('btnOpenAll').style.display = 'none';
        document.getElementById('btnDownloadAll').style.display = 'none';
        return;
      }
      stats.textContent = urls.length === 1 ? '1 link generato.' : `${urls.length} link generati.`;
      urls.forEach((u, i) => {
        const div = document.createElement('div');
        div.className = 'out-item';
        div.innerHTML = `
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:center;">
            <div class="mono" style="flex:1 1 auto;">${u}</div>
            <div class="row" style="flex:0 0 auto;">
              <button class="btn small ghost" data-copy>CopIA</button>
              <button class="btn small" data-open>Apri</button>
            </div>
          </div>`;
        div.querySelector('[data-copy]').addEventListener('click', async () => {
          await navigator.clipboard.writeText(u);
          toast('URL copiato');
        });
        div.querySelector('[data-open]').addEventListener('click', async () => {
          const ok = await confirmAction('Aprire il link in una nuova scheda?');
          if (ok) window.open(u, '_blank', 'noopener');
        });
        out.appendChild(div);
      });
      document.getElementById('btnOpenAll').style.display = urls.length > 1 ? '' : 'none';
      document.getElementById('btnDownloadAll').style.display = '';
    }

    function nowStamp(){
      const d = new Date();
      const pad = n => String(n).padStart(2,'0');
      return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
    }

    function downloadTxt(name, lines){
      const blob = new Blob([lines.join('\n')], { type:'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = name; document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    // Main handler
    document.getElementById('btnMerge').addEventListener('click', async () => {
      const raw = document.getElementById('linksInput').value
        .split('\n')
        .map(s => s.trim())
        .filter(Boolean);
      if (!raw.length){ toast('Inserisci almeno una riga'); return; }

      // Step 1: resolve short links where needed
      const resolved = [];
      for (const line of raw){
        try { resolved.push(await resolveIfShort(line)); }
        catch { resolved.push(line); }
      }

      const chkSanitize = document.getElementById('chkSanitize').checked;
      const chkDedupe = document.getElementById('chkDedupe').checked;
      const chkAddCurrent = document.getElementById('chkAddCurrent').checked;

      // Step 2: extract points from each line
      let points = [];
      for (const line of resolved){
        const arr = extractPointsFromUrl(line);
        points.push(...arr);
      }

      // Step 3: sanitize tokens
      points = points.map(p => sanitizePointToken(p));

      // Step 4: optional dedupe (off by default, per policy pregressa)
      if (chkDedupe) points = dedupeOrdered(points);

      // Step 5: if only 1 real point (no dir), optionally add '//'
      const hasSlash = points[0] === '//';
      if (!hasSlash && points.length === 1 && chkAddCurrent){
        points.unshift('//');
      }

      // Step 6: Decide strategy
      const limit = 25;
      const total = points.length;

      // Build outputs according to length
      let urls = [];
      if (total <= limit){
        urls = [ buildDirectionsURL(points) ];
      } else {
        const strategy = await chooseStrategy();
        if (!strategy){ toast('Operazione annullata'); return; }
        if (strategy === 'optimize'){
          const reduced = optimizeTo25(points);
          urls = [ buildDirectionsURL(reduced) ];
        } else if (strategy === 'split'){
          const blocks = splitInBlocks(points);
          urls = blocks.map(b => buildDirectionsURL(b));
        }
      }

      renderOutput(urls);
    });

    document.getElementById('btnClear').addEventListener('click', () => {
      document.getElementById('linksInput').value = '';
      document.getElementById('output').innerHTML = '';
      document.getElementById('stats').textContent = 'Pulito.';
      document.getElementById('btnOpenAll').style.display = 'none';
      document.getElementById('btnDownloadAll').style.display = 'none';
    });

    document.getElementById('btnOpenAll').addEventListener('click', async () => {
      const items = Array.from(document.querySelectorAll('#output .out-item .mono')).map(x => x.textContent);
      if (!items.length) return;
      const ok = await confirmAction('Aprire tutti i link in nuove schede?');
      if (!ok) return;
      for (const u of items){ window.open(u, '_blank', 'noopener'); }
    });

    document.getElementById('btnDownloadAll').addEventListener('click', async () => {
      const items = Array.from(document.querySelectorAll('#output .out-item .mono')).map(x => x.textContent);
      if (!items.length) return;
      const ok = await confirmAction('Scaricare un file .txt con i link generati?');
      if (!ok) return;
      const name = (items.length === 1 ? `merge_1_${nowStamp()}.txt` : `merge_${items.length}_${nowStamp()}.txt`);
      downloadTxt(name, items);
      toast('File scaricato');
    });
  </script>
</body>
</html>
```

---

# worker.js (Cloudflare Workers)

```js
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);

    // CORS preflight
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders() });
    }

    if (url.pathname === '/' || url.pathname === '') {
      return json({ ok: true, service: 'gpx2maps-worker', endpoints: ['/resolve'] });
    }

    if (url.pathname === '/resolve') {
      const target = url.searchParams.get('url');
      if (!target) return json({ error: 'missing url' }, 400);
      try {
        const finalUrl = await resolveRedirects(target, 5);
        return json({ finalUrl });
      } catch (e) {
        return json({ error: String(e) }, 500);
      }
    }

    return json({ error: 'not found' }, 404);
  }
}

function corsHeaders() {
  return {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET,OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type,Accept',
  };
}

function json(obj, status = 200) {
  return new Response(JSON.stringify(obj), {
    status,
    headers: { 'Content-Type': 'application/json; charset=utf-8', ...corsHeaders() }
  });
}

async function resolveRedirects(inputUrl, maxHops = 5) {
  let current = inputUrl;
  for (let i = 0; i < maxHops; i++) {
    const resp = await fetch(current, { redirect: 'manual' });
    const status = resp.status;
    if (status >= 300 && status < 400) {
      const loc = resp.headers.get('location');
      if (!loc) break;
      // handle relative redirects
      current = new URL(loc, current).toString();
      continue;
    }
    if (status === 200) {
      // If no more redirects, return current
      return current;
    }
    // Non-redirect terminal status
    return current;
  }
  return current;
}
```
